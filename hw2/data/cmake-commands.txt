One MiB (mebibyte) is equal to 1024x1024 bytes. cmake_minimum_required Require a minimum version of cmake. cmake_minimum_required(VERSION <min>[...<max>] [FATAL_ERROR]) Sets the minimum required version of cmake for a project. Also updates the policy settings as explained below. <min> and the optional <max> are each CMake versions of the form major.minor[.patch[.tweak]], and the ... is literal. If the running version of CMake is lower than the <min> required version it will stop processing the project and report an error. The optional <max> version, if specified, must be at least the <min> version and affects policy settings as described below. If the running version of CMake is older than 3.12, the extra ... dots will be seen as version component separators, resulting in the ...<max> part being ignored and preserving the pre-3.12 behavior of basing policies on <min>. The FATAL_ERROR option is accepted but ignored by CMake 2.6 and higher. It should be specified so CMake versions 2.4 and lower fail with an error instead of just a warning. NOTE: Call the cmake_minimum_required() command at the beginning of the top-level CMakeLists.txt file even before calling the project() command. It is important to establish version and policy settings before invoking other commands whose behavior they may affect. See also policy CMP0000. Calling cmake_minimum_required() inside a function() limits some effects to the function scope when invoked. Such calls should not be made with the intention of having global effects. Policy Settings The cmake_minimum_required(VERSION) command implicitly invokes the cmake_policy(VERSION) command to specify that the current project code is writ‐ ten for the given range of CMake versions. All policies known to the running version of CMake and introduced in the <min> (or <max>, if speci‐ fied) version or earlier will be set to use NEW behavior. All policies introduced in later versions will be unset. This effectively requests be‐ havior preferred as of a given CMake version and tells newer CMake versions to warn about their new policies. When a <min> version higher than 2.4 is specified the command implicitly invokes cmake_policy(VERSION <min>[...<max>]) which sets CMake policies based on the range of versions specified. When a <min> version 2.4 or lower is given the command implicitly invokes cmake_policy(VERSION 2.4[...<max>]) which enables compatibility features for CMake 2.4 and lower. cmake_parse_arguments Parse function or macro arguments. cmake_parse_arguments(<prefix> <options> <one_value_keywords> <multi_value_keywords> <args>...) cmake_parse_arguments(PARSE_ARGV <N> <prefix> <options> <one_value_keywords> <multi_value_keywords>) This command is for use in macros or functions. It processes the arguments given to that macro or function, and defines a set of variables which hold the values of the respective options. The first signature reads processes arguments passed in the <args>.... This may be used in either a macro() or a function(). The PARSE_ARGV signature is only for use in a function() body. In this case the arguments that are parsed come from the ARGV# variables of the calling function. The parsing starts with the <N>-th argument, where <N> is an unsigned integer. This allows for the values to have special characters like ; in them. The <options> argument contains all options for the respective macro, i.e. keywords which can be used when calling the macro without any value following, like e.g. the OPTIONAL keyword of the install() command. The <one_value_keywords> argument contains all keywords for this macro which are followed by one value, like e.g. DESTINATION keyword of the in‐ stall() command. The <multi_value_keywords> argument contains all keywords for this macro which can be followed by more than one value, like e.g. the TARGETS or FILES keywords of the install() command. NOTE: All keywords shall be unique. I.e. every keyword shall only be specified once in either <options>, <one_value_keywords> or <multi_value_key‐ words>. A warning will be emitted if uniqueness is violated. When done, cmake_parse_arguments will consider for each of the keywords listed in <options>, <one_value_keywords> and <multi_value_keywords> a variable composed of the given <prefix> followed by _ and the name of the respective keyword. These variables will then hold the respective value from the argument list or be undefined if the associated option could not be found. For the <options> keywords, these will always be de‐ fined, to TRUE or FALSE, whether the option is in the argument list or not. All remaining arguments are collected in a variable <prefix>_UNPARSED_ARGUMENTS that will be undefined if all arguments were recognized. This can be checked afterwards to see whether your macro was called with unrecognized parameters. <one_value_keywords> and <multi_value_keywords> that were given no values at all are collected in a variable <prefix>_KEYWORDS_MISSING_VALUES that will be undefined if all keywords received values. This can be checked to see if there were keywords without any values given. Consider the following example macro, my_install(), which takes similar arguments to the real install() command: macro(my_install) set(options OPTIONAL FAST) set(oneValueArgs DESTINATION RENAME) set(multiValueArgs TARGETS CONFIGURATIONS) cmake_parse_arguments(MY_INSTALL ${options} ${oneValueArgs} ${multiValueArgs} ${ARGN} ) # ... Assume my_install() has been called like this: my_install(TARGETS foo bar DESTINATION bin OPTIONAL blub CONFIGURATIONS) After the cmake_parse_arguments call the macro will have set or undefined the following variables: MY_INSTALL_OPTIONAL = TRUE MY_INSTALL_FAST = FALSE # was not used in call to my_install MY_INSTALL_DESTINATION = bin MY_INSTALL_RENAME <UNDEFINED> # was not used MY_INSTALL_TARGETS = foo;bar MY_INSTALL_CONFIGURATIONS <UNDEFINED> # was not used MY_INSTALL_UNPARSED_ARGUMENTS = blub # nothing expected after OPTIONAL MY_INSTALL_KEYWORDS_MISSING_VALUES = CONFIGURATIONS # No value for CONFIGURATIONS given You can then continue and process these variables. Keywords terminate lists of values, e.g. if directly after a one_value_keyword another recognized keyword follows, this is interpreted as the be‐ ginning of the new option. E.g. my_install(TARGETS foo DESTINATION OPTIONAL) would result in MY_INSTALL_DESTINATION set to OPTIONAL, but as OPTIONAL is a keyword itself MY_INSTALL_DESTINATION will be empty (but added to MY_INSTALL_KEYWORDS_MISSING_VALUES) and MY_INSTALL_OPTIONAL will therefore be set to TRUE. cmake_policy Manage CMake Policy settings. See the cmake-policies(7) manual for defined policies. As CMake evolves it is sometimes necessary to change existing behavior in order to fix bugs or improve implementations of existing features. The CMake Policy mechanism is designed to help keep existing projects building as new versions of CMake introduce changes in behavior. Each new pol‐ icy (behavioral change) is given an identifier of the form CMP<NNNN> where <NNNN> is an integer index. Documentation associated with each policy describes the OLD and NEW behavior and the reason the policy was introduced. Projects may set each policy to select the desired behavior. When CMake needs to know which behavior to use it checks for a setting specified by the project. If no setting is available the OLD behavior is as‐ sumed and a warning is produced requesting that the policy be set. Setting Policies by CMake Version The cmake_policy command is used to set policies to OLD or NEW behavior. While setting policies individually is supported, we encourage projects to set policies based on CMake versions: cmake_policy(VERSION <min>[...<max>]) <min> and the optional <max> are each CMake versions of the form major.minor[.patch[.tweak]], and the ... is literal. The <min> version must be at least 2.4 and at most the running version of CMake. The <max> version, if specified, must be at least the <min> version but may exceed the running version of CMake. If the running version of CMake is older than 3.12, the extra ... dots will be seen as version component separators, resulting in the ...<max> part being ignored and preserving the pre-3.12 behavior of basing policies on <min>. This specifies that the current CMake code is written for the given range of CMake versions. All policies known to the running version of CMake and introduced in the <min> (or <max>, if specified) version or earlier will be set to use NEW behavior. All policies introduced in later ver‐ sions will be unset (unless the CMAKE_POLICY_DEFAULT_CMP<NNNN> variable sets a default). This effectively requests behavior preferred as of a given CMake version and tells newer CMake versions to warn about their new policies. Note that the cmake_minimum_required(VERSION) command implicitly calls cmake_policy(VERSION) too. Setting Policies Explicitly cmake_policy(SET CMP<NNNN> NEW) cmake_policy(SET CMP<NNNN> OLD) Tell CMake to use the OLD or NEW behavior for a given policy. Projects depending on the old behavior of a given policy may silence a policy warn‐ ing by setting the policy state to OLD. Alternatively one may fix the project to work with the new behavior and set the policy state to NEW. NOTE: The OLD behavior of a policy is deprecated by definition and may be removed in a future version of CMake. Checking Policy Settings cmake_policy(GET CMP<NNNN> <variable>) Check whether a given policy is set to OLD or NEW behavior. The output <variable> value will be OLD or NEW if the policy is set, and empty other‐ wise. CMake Policy Stack CMake keeps policy settings on a stack, so changes made by the cmake_policy command affect only the top of the stack. A new entry on the policy stack is managed automatically for each subdirectory to protect its parents and siblings. CMake also manages a new entry for scripts loaded by include() and find_package() commands except when invoked with the NO_POLICY_SCOPE option (see also policy CMP0011). The cmake_policy command provides an interface to manage custom entries on the policy stack: cmake_policy(PUSH) cmake_policy(POP) Each PUSH must have a matching POP to erase any changes. This is useful to make temporary changes to policy settings. Calls to the cmake_mini‐ mum_required(VERSION), cmake_policy(VERSION), or cmake_policy(SET) commands influence only the current top of the policy stack. Commands created by the function() and macro() commands record policy settings when they are created and use the pre-record policies when they are invoked. If the function or macro implementation sets policies, the changes automatically propagate up through callers until they reach the clos‐ est nested policy stack entry. configure_file Copy a file to another location and modify its contents. configure_file(<input> <output> [COPYONLY] [ESCAPE_QUOTES] [@ONLY] [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ]) Copies an <input> file to an <output> file and substitutes variable values referenced as @VAR@ or ${VAR} in the input file content. Each variable reference will be replaced with the current value of the variable, or the empty string if the variable is not defined. Furthermore, input lines of the form #cmakedefine VAR ... will be replaced with either #define VAR ... or /* #undef VAR */ depending on whether VAR is set in CMake to any value not considered a false constant by the if() command. The “…” content on the line after the variable name, if any, is processed as above. Input file lines of the form #cmakedefine01 VAR will be replaced with either #define VAR 1 or #de‐ fine VAR 0 similarly. The result lines (with the exception of the #undef comments) can be indented using spaces and/or tabs between the # charac‐ ter and the cmakedefine or cmakedefine01 words. This whitespace indentation will be preserved in the output lines: # cmakedefine VAR # cmakedefine01 VAR will be replaced, if VAR is defined, with # define VAR # define VAR 1 If the input file is modified the build system will re-run CMake to re-configure the file and generate the build system again. The generated file is modified and its timestamp updated on subsequent cmake runs only if its content is changed. The arguments are: <input> Path to the input file. A relative path is treated with respect to the value of CMAKE_CURRENT_SOURCE_DIR. The input path must be a file, not a directory. <output> Path to the output file or directory. A relative path is treated with respect to the value of CMAKE_CURRENT_BINARY_DIR. If the path names an existing directory the output file is placed in that directory with the same file name as the input file. COPYONLY Copy the file without replacing any variable references or other content. This option may not be used with NEWLINE_STYLE. ESCAPE_QUOTES Escape any substituted quotes with backslashes (C-style). @ONLY Restrict variable replacement to references of the form @VAR@. This is useful for configuring scripts that use ${VAR} syntax. NEWLINE_STYLE <style> Specify the newline style for the output file. Specify UNIX or LF for n newlines, or specify DOS, WIN32, or CRLF for rn newlines. This option may not be used with COPYONLY. Example Consider a source tree containing a foo.h.in file: #cmakedefine FOO_ENABLE #cmakedefine FOO_STRING @FOO_STRING@ An adjacent CMakeLists.txt may use configure_file to configure the header: option(FOO_ENABLE Enable Foo ON) if(FOO_ENABLE) set(FOO_STRING foo) endif() configure_file(foo.h.in foo.h @ONLY) This creates a foo.h in the build directory corresponding to this source directory. If the FOO_ENABLE option is on, the configured file will con‐ tain: #define FOO_ENABLE #define FOO_STRING foo Otherwise it will contain: /* #undef FOO_ENABLE */ /* #undef FOO_STRING */ One may then use the include_directories() command to specify the output directory as an include directory: include_directories(${CMAKE_CURRENT_BINARY_DIR}) so that sources may include the header as #include <foo.h>. continue Continue to the top of enclosing foreach or while loop. continue() The continue command allows a cmake script to abort the rest of a block in a foreach() or while() loop, and start at the top of the next itera‐ tion. See also the break() command. else Starts the else portion of an if block. else([<condition>]) See the if() command. elseif Starts an elseif portion of an if block. elseif(<condition>) See the if() command, especially for the syntax and logic of the <condition>. endforeach Ends a list of commands in a foreach block. endforeach([<loop_var>]) See the foreach() command. The optional <loop_var> argument is supported for backward compatibility only. If used it must be a verbatim repeat of the <loop_var> argument of the opening foreach clause. endfunction Ends a list of commands in a function block. endfunction([<name>]) See the function() command. The optional <name> argument is supported for backward compatibility only. If used it must be a verbatim repeat of the <name> argument of the opening function command. endif Ends a list of commands in an if block. endif([<condition>]) See the if() command. The optional <condition> argument is supported for backward compatibility only. If used it must be a verbatim repeat of the argument of the open‐ ing if clause. endmacro Ends a list of commands in a macro block. endmacro([<name>]) See the macro() command. The optional <name> argument is supported for backward compatibility only. If used it must be a verbatim repeat of the <name> argument of the opening macro command. endwhile Ends a list of commands in a while block. endwhile([<condition>]) See the while() command. The optional <condition> argument is supported for backward compatibility only. If used it must be a verbatim repeat of the argument of the open‐ ing while clause. execute_process Execute one or more child processes. execute_process(COMMAND <cmd1> [<arguments>] [COMMAND <cmd2> [<arguments>]]... [WORKING_DIRECTORY <directory>] [TIMEOUT <seconds>] [RESULT_VARIABLE <variable>] [RESULTS_VARIABLE <variable>] [OUTPUT_VARIABLE <variable>] [ERROR_VARIABLE <variable>] [INPUT_FILE <file>] [OUTPUT_FILE <file>] [ERROR_FILE <file>] [OUTPUT_QUIET] [ERROR_QUIET] [COMMAND_ECHO <where>] [OUTPUT_STRIP_TRAILING_WHITESPACE] [ERROR_STRIP_TRAILING_WHITESPACE] [ENCODING <name>]) Runs the given sequence of one or more commands. Commands are executed concurrently as a pipeline, with the standard output of each process piped to the standard input of the next. A single standard error pipe is used for all processes. Options: COMMAND A child process command line. CMake executes the child process using operating system APIs directly. All arguments are passed VERBATIM to the child process. No inter‐ mediate shell is used, so shell operators such as > are treated as normal arguments. (Use the INPUT_*, OUTPUT_*, and ERROR_* options to redirect stdin, stdout, and stderr.) If a sequential execution of multiple commands is required, use multiple execute_process() calls with a single COMMAND argument. WORKING_DIRECTORY The named directory will be set as the current working directory of the child processes. TIMEOUT After the specified number of seconds (fractions allowed), all unfinished child processes will be terminated, and the RESULT_VARIABLE will be set to a string mentioning the “timeout”. RESULT_VARIABLE The variable will be set to contain the result of last child process. This will be an integer return code from the last child or a string describing an error condition. RESULTS_VARIABLE <variable> The variable will be set to contain the result of all processes as a semicolon-separated list, in order of the given COMMAND arguments. Each entry will be an integer return code from the corresponding child or a string describing an error condition. OUTPUT_VARIABLE, ERROR_VARIABLE The variable named will be set with the contents of the standard output and standard error pipes, respectively. If the same variable is named for both pipes their output will be merged in the order produced. INPUT_FILE, OUTPUT_FILE, ERROR_FILE The file named will be attached to the standard input of the first process, standard output of the last process, or standard error of all processes, respectively. If the same file is named for both output and error then it will be used for both. OUTPUT_QUIET, ERROR_QUIET The standard output or standard error results will be quietly ignored. COMMAND_ECHO <where> The command being run will be echo’ed to <where> with <where> being set to one of STDERR, STDOUT or NONE. See the CMAKE_EXE‐ CUTE_PROCESS_COMMAND_ECHO variable for a way to control the default behavior when this option is not present. ENCODING <name> On Windows, the encoding that is used to decode output from the process. Ignored on other platforms. Valid encoding names are: NONE Perform no decoding. This assumes that the process output is encoded in the same way as CMake’s internal encoding (UTF-8). This is the default. AUTO Use the current active console’s codepage or if that isn’t available then use ANSI. ANSI Use the ANSI codepage. OEM Use the original equipment manufacturer (OEM) code page. UTF8 or UTF-8 Use the UTF-8 codepage. Prior to CMake 3.11.0, only UTF8 was accepted for this encoding. In CMake 3.11.0, UTF-8 was added for con‐ sistency with the UTF-8 RFC naming convention. If more than one OUTPUT_* or ERROR_* option is given for the same pipe the precedence is not specified. If no OUTPUT_* or ERROR_* options are given the output will be shared with the corresponding pipes of the CMake process itself. The execute_process() command is a newer more powerful version of exec_program(), but the old command has been kept for compatibility. Both com‐ mands run while CMake is processing the project prior to build system generation. Use add_custom_target() and add_custom_command() to create cus‐ tom commands that run at build time. file File manipulation command. Synopsis Reading file(READ <filename> <out-var> [...]) file(STRINGS <filename> <out-var> [...]) file(<HASH> <filename> <out-var>) file(TIMESTAMP <filename> <out-var> [...]) file(GET_RUNTIME_DEPENDENCIES [...]) Writing file({WRITE | APPEND} <filename> <content>...) file({TOUCH | TOUCH_NOCREATE} [<file>...]) file(GENERATE OUTPUT <output-file> [...]) Filesystem file({GLOB | GLOB_RECURSE} <out-var> [...] [<globbing-expr>...]) file(RENAME <oldname> <newname>) file({REMOVE | REMOVE_RECURSE } [<files>...]) file(MAKE_DIRECTORY [<dir>...]) file({COPY | INSTALL} <file>... DESTINATION <dir> [...]) file(SIZE <filename> <out-var>) file(READ_SYMLINK <linkname> <out-var>) file(CREATE_LINK <original> <linkname> [...]) Path Conversion file(RELATIVE_PATH <out-var> <directory> <file>) file({TO_CMAKE_PATH | TO_NATIVE_PATH} <path> <out-var>) Transfer file(DOWNLOAD <url> <file> [...]) file(UPLOAD <file> <url> [...]) Locking file(LOCK <path> [...]) Reading file(READ <filename> <variable> [OFFSET <offset>] [LIMIT <max-in>] [HEX]) Read content from a file called <filename> and store it in a <variable>. Optionally start from the given <offset> and read at most <max-in> bytes. The HEX option causes data to be converted to a hexadecimal representation (useful for binary data). file(STRINGS <filename> <variable> [<options>...]) Parse a list of ASCII strings from <filename> and store it in <variable>. Binary data in the file are ignored. Carriage return (r, CR) charac‐ ters are ignored. The options are: LENGTH_MAXIMUM <max-len> Consider only strings of at most a given length. LENGTH_MINIMUM <min-len> Consider only strings of at least a given length. LIMIT_COUNT <max-num> Limit the number of distinct strings to be extracted. LIMIT_INPUT <max-in> Limit the number of input bytes to read from the file. LIMIT_OUTPUT <max-out> Limit the number of total bytes to store in the <variable>. NEWLINE_CONSUME Treat newline characters (n, LF) as part of string content instead of terminating at them. NO_HEX_CONVERSION Intel Hex and Motorola S-record files are automatically converted to binary while reading unless this option is given. REGEX <regex> Consider only strings that match the given regular expression. ENCODING <encoding-type> Consider strings of a given encoding. Currently supported encodings are: UTF-8, UTF-16LE, UTF-16BE, UTF-32LE, UTF-32BE. If the ENCODING option is not provided and the file has a Byte Order Mark, the ENCODING option will be defaulted to respect the Byte Order Mark. For example, the code file(STRINGS myfile.txt myfile) stores a list in the variable myfile in which each item is a line from the input file. file(<HASH> <filename> <variable>) Compute a cryptographic hash of the content of <filename> and store it in a <variable>. The supported <HASH> algorithm names are those listed by the string(<HASH>) command. file(TIMESTAMP <filename> <variable> [<format>] [UTC]) Compute a string representation of the modification time of <filename> and store it in <variable>. Should the command be unable to obtain a time‐ stamp variable will be set to the empty string (“”). See the string(TIMESTAMP) command for documentation of the <format> and UTC options. file(GET_RUNTIME_DEPENDENCIES [RESOLVED_DEPENDENCIES_VAR <deps_var>] [UNRESOLVED_DEPENDENCIES_VAR <unresolved_deps_var>] [CONFLICTING_DEPENDENCIES_PREFIX <conflicting_deps_prefix>] [EXECUTABLES [<executable_files>...]] [LIBRARIES [<library_files>...]] [MODULES [<module_files>...]] [DIRECTORIES [<directories>...]] [BUNDLE_EXECUTABLE <bundle_executable_file>] [PRE_INCLUDE_REGEXES [<regexes>...]] [PRE_EXCLUDE_REGEXES [<regexes>...]] [POST_INCLUDE_REGEXES [<regexes>...]] [POST_EXCLUDE_REGEXES [<regexes>...]] ) Recursively get the list of libraries depended on by the given files. Please note that this sub-command is not intended to be used in project mode. Instead, use it in an install(CODE) or install(SCRIPT) block. For example: install(CODE [[ file(GET_RUNTIME_DEPENDENCIES # ... ) ]]) The arguments are as follows: RESOLVED_DEPENDENCIES_VAR <deps_var> Name of the variable in which to store the list of resolved dependencies. UNRESOLVED_DEPENDENCIES_VAR <unresolved_deps_var> Name of the variable in which to store the list of unresolved dependencies. If this variable is not specified, and there are any unre‐ solved dependencies, an error is issued. CONFLICTING_DEPENDENCIES_PREFIX <conflicting_deps_prefix> Variable prefix in which to store conflicting dependency information. Dependencies are conflicting if two files with the same name are found in two different directories. The list of filenames that conflict are stored in <conflicting_deps_prefix>_FILENAMES. For each file‐ name, the list of paths that were found for that filename are stored in <conflicting_deps_prefix>_<filename>. EXECUTABLES <executable_files> List of executable files to read for dependencies. These are executables that are typically created with add_executable(), but they do not have to be created by CMake. On Apple platforms, the paths to these files determine the value of @executable_path when recursively resolv‐ ing the libraries. Specifying any kind of library (STATIC, MODULE, or SHARED) here will result in undefined behavior. LIBRARIES <library_files> List of library files to read for dependencies. These are libraries that are typically created with add_library(SHARED), but they do not have to be created by CMake. Specifying STATIC libraries, MODULE libraries, or executables here will result in undefined behavior. MODULES <module_files> List of loadable module files to read for dependencies. These are modules that are typically created with add_library(MODULE), but they do not have to be created by CMake. They are typically used by calling dlopen() at runtime rather than linked at link time with ld -l. Speci‐ fying STATIC libraries, SHARED libraries, or executables here will result in undefined behavior. DIRECTORIES <directories> List of additional directories to search for dependencies. On Linux platforms, these directories are searched if the dependency is not found in any of the other usual paths. If it is found in such a directory, a warning is issued, because it means that the file is incom‐ plete (it does not list all of the directories that contain its dependencies). On Windows platforms, these directories are searched if the dependency is not found in any of the other search paths, but no warning is issued, because searching other paths is a normal part of Win‐ dows dependency resolution. On Apple platforms, this argument has no effect. BUNDLE_EXECUTABLE <bundle_executable_file> Executable to treat as the “bundle executable” when resolving libraries. On Apple platforms, this argument determines the value of @exe‐ cutable_path when recursively resolving libraries for LIBRARIES and MODULES files. It has no effect on EXECUTABLES files. On other plat‐ forms, it has no effect. This is typically (but not always) one of the executables in the EXECUTABLES argument which designates the “main” executable of the package. The following arguments specify filters for including or excluding libraries to be resolved. See below for a full description of how they work. PRE_INCLUDE_REGEXES <regexes> List of pre-include regexes through which to filter the names of not-yet-resolved dependencies. PRE_EXCLUDE_REGEXES <regexes> List of pre-exclude regexes through which to filter the names of not-yet-resolved dependencies. POST_INCLUDE_REGEXES <regexes> List of post-include regexes through which to filter the names of resolved dependencies. POST_EXCLUDE_REGEXES <regexes> List of post-exclude regexes through which to filter the names of resolved dependencies. These arguments can be used to blacklist unwanted system libraries when resolving the dependencies, or to whitelist libraries from a specific di‐ rectory. The filtering works as follows: 1. If the not-yet-resolved dependency matches any of the PRE_INCLUDE_REGEXES, steps 2 and 3 are skipped, and the dependency resolution proceeds to step 4. 2. If the not-yet-resolved dependency matches any of the PRE_EXCLUDE_REGEXES, dependency resolution stops for that dependency. 3. Otherwise, dependency resolution proceeds. 4. file(GET_RUNTIME_DEPENDENCIES) searches for the dependency according to the linking rules of the platform (see below). 5. If the dependency is found, and its full path matches one of the POST_INCLUDE_REGEXES, the full path is added to the resolved dependencies, and file(GET_RUNTIME_DEPENDENCIES) recursively resolves that library’s own dependencies. Otherwise, resolution proceeds to step 6. 6. If the dependency is found, but its full path matches one of the POST_EXCLUDE_REGEXES, it is not added to the resolved dependencies, and depen‐ dency resolution stops for that dependency. 7. If the dependency is found, and its full path does not match either POST_INCLUDE_REGEXES or POST_EXCLUDE_REGEXES, the full path is added to the resolved dependencies, and file(GET_RUNTIME_DEPENDENCIES) recursively resolves that library’s own dependencies. Different platforms have different rules for how dependencies are resolved. These specifics are described here. On Linux platforms, library resolution works as follows: 1. If the depending file does not have any RUNPATH entries, and the library exists in one of the depending file’s RPATH entries, or its parents’, in that order, the dependency is resolved to that file. 2. Otherwise, if the depending file has any RUNPATH entries, and the library exists in one of those entries, the dependency is resolved to that file. 3. Otherwise, if the library exists in one of the directories listed by ldconfig, the dependency is resolved to that file. 4. Otherwise, if the library exists in one of the DIRECTORIES entries, the dependency is resolved to that file. In this case, a warning is issued, because finding a file in one of the DIRECTORIES means that the depending file is not complete (it does not list all the directories from which it pulls dependencies). 5. Otherwise, the dependency is unresolved. On Windows platforms, library resolution works as follows: 1. The dependent DLL name is converted to lowercase. Windows DLL names are case-insensitive, and some linkers mangle the case of the DLL depen‐ dency names. However, this makes it more difficult for PRE_INCLUDE_REGEXES, PRE_EXCLUDE_REGEXES, POST_INCLUDE_REGEXES, and POST_EXCLUDE_REGEXES to properly filter DLL names - every regex would have to check for both uppercase and lowercase letters. For example: file(GET_RUNTIME_DEPENDENCIES # ... PRE_INCLUDE_REGEXES ^[Mm][Yy][Ll][Ii][Bb][Rr][Aa][Rr][Yy]\\.[Dd][Ll][Ll]$ ) Converting the DLL name to lowercase allows the regexes to only match lowercase names, thus simplifying the regex. For example: file(GET_RUNTIME_DEPENDENCIES # ... PRE_INCLUDE_REGEXES ^mylibrary\\.dll$ ) This regex will match mylibrary.dll regardless of how it is cased, either on disk or in the depending file. (For example, it will match myli‐ brary.dll, MyLibrary.dll, and MYLIBRARY.DLL.) Please note that the directory portion of any resolved DLLs retains its casing and is not converted to lowercase. Only the filename portion is converted. 2. (Not yet implemented) If the depending file is a Windows Store app, and the dependency is listed as a dependency in the application’s package manifest, the dependency is resolved to that file. 3. Otherwise, if the library exists in the same directory as the depending file, the dependency is resolved to that file. 4. Otherwise, if the library exists in either the operating system’s system32 directory or the Windows directory, in that order, the dependency is resolved to that file. 5. Otherwise, if the library exists in one of the directories specified by DIRECTORIES, in the order they are listed, the dependency is resolved to that file. In this case, a warning is not issued, because searching other directories is a normal part of Windows library resolution. 6. Otherwise, the dependency is unresolved. On Apple platforms, library resolution works as follows: 1. If the dependency starts with @executable_path/, and an EXECUTABLES argument is in the process of being resolved, and replacing @exe‐ cutable_path/ with the directory of the executable yields an existing file, the dependency is resolved to that file. 2. Otherwise, if the dependency starts with @executable_path/, and there is a BUNDLE_EXECUTABLE argument, and replacing @executable_path/ with the directory of the bundle executable yields an existing file, the dependency is resolved to that file. 3. Otherwise, if the dependency starts with @loader_path/, and replacing @loader_path/ with the directory of the depending file yields an existing file, the dependency is resolved to that file. 4. Otherwise, if the dependency starts with @rpath/, and replacing @rpath/ with one of the RPATH entries of the depending file yields an existing file, the dependency is resolved to that file. Note that RPATH entries that start with @executable_path/ or @loader_path/ also have these items replaced with the appropriate path. 5. Otherwise, if the dependency is an absolute file that exists, the dependency is resolved to that file. 6. Otherwise, the dependency is unresolved. This function accepts several variables that determine which tool is used for dependency resolution: CMAKE_GET_RUNTIME_DEPENDENCIES_PLATFORM Determines which operating system and executable format the files are built for. This could be one of several values: • linux+elf • windows+pe • macos+macho If this variable is not specified, it is determined automatically by system introspection. CMAKE_GET_RUNTIME_DEPENDENCIES_TOOL Determines the tool to use for dependency resolution. It could be one of several values, depending on the value of CMAKE_GET_RUNTIME_DEPENDENCIES_PLATFORM: ┌────────────────────────────────────────┬─────────────────────────────────────┐ │CMAKE_GET_RUNTIME_DEPENDENCIES_PLATFORM │ CMAKE_GET_RUNTIME_DEPENDENCIES_TOOL │ ├────────────────────────────────────────┼─────────────────────────────────────┤ │linux+elf │ objdump │ ├────────────────────────────────────────┼─────────────────────────────────────┤ │windows+pe │ dumpbin │ ├────────────────────────────────────────┼─────────────────────────────────────┤ │windows+pe │ objdump │ ├────────────────────────────────────────┼─────────────────────────────────────┤ │macos+macho │ otool │ └────────────────────────────────────────┴─────────────────────────────────────┘ If this variable is not specified, it is determined automatically by system introspection. CMAKE_GET_RUNTIME_DEPENDENCIES_COMMAND Determines the path to the tool to use for dependency resolution. This is the actual path to objdump, dumpbin, or otool. If this variable is not specified, it is determined automatically by system introspection. Writing file(WRITE <filename> <content>...) file(APPEND <filename> <content>...) Write <content> into a file called <filename>. If the file does not exist, it will be created. If the file already exists, WRITE mode will over‐ write it and APPEND mode will append to the end. Any directories in the path specified by <filename> that do not exist will be created. If the file is a build input, use the configure_file() command to update the file only when its content changes. file(TOUCH [<files>...]) file(TOUCH_NOCREATE [<files>...]) Create a file with no content if it does not yet exist. If the file already exists, its access and/or modification will be updated to the time when the function call is executed. Use TOUCH_NOCREATE to touch a file if it exists but not create it. If a file does not exist it will be silently ignored. With TOUCH and TOUCH_NOCREATE the contents of an existing file will not be modified. file(GENERATE OUTPUT output-file <INPUT input-file|CONTENT content> [CONDITION expression]) Generate an output file for each build configuration supported by the current CMake Generator. Evaluate generator expressions from the input con‐ tent to produce the output content. The options are: CONDITION <condition> Generate the output file for a particular configuration only if the condition is true. The condition must be either 0 or 1 after evaluat‐ ing generator expressions. CONTENT <content> Use the content given explicitly as input. INPUT <input-file> Use the content from a given file as input. A relative path is treated with respect to the value of CMAKE_CURRENT_SOURCE_DIR. See policy CMP0070. OUTPUT <output-file> Specify the output file name to generate. Use generator expressions such as $<CONFIG> to specify a configuration-specific output file name. Multiple configurations may generate the same output file only if the generated content is identical. Otherwise, the <output-file> must evaluate to an unique name for each configuration. A relative path (after evaluating generator expressions) is treated with respect to the value of CMAKE_CURRENT_BINARY_DIR. See policy CMP0070. Exactly one CONTENT or INPUT option must be given. A specific OUTPUT file may be named by at most one invocation of file(GENERATE). Generated files are modified and their timestamp updated on subsequent cmake runs only if their content is changed. Note also that file(GENERATE) does not create the output file until the generation phase. The output file will not yet have been written when the file(GENERATE) command returns, it is written only after processing all of a project’s CMakeLists.txt files. Filesystem file(GLOB <variable> [LIST_DIRECTORIES true|false] [RELATIVE <path>] [CONFIGURE_DEPENDS] [<globbing-expressions>...]) file(GLOB_RECURSE <variable> [FOLLOW_SYMLINKS] [LIST_DIRECTORIES true|false] [RELATIVE <path>] [CONFIGURE_DEPENDS] [<globbing-expressions>...]) Generate a list of files that match the <globbing-expressions> and store it into the <variable>. Globbing expressions are similar to regular ex‐ pressions, but much simpler. If RELATIVE flag is specified, the results will be returned as relative paths to the given path. The results will be ordered lexicographically. On Windows and macOS, globbing is case-insensitive even if the underlying filesystem is case-sensitive (both filenames and globbing expressions are converted to lowercase before matching). On other platforms, globbing is case-sensitive. If the CONFIGURE_DEPENDS flag is specified, CMake will add logic to the main build system check target to rerun the flagged GLOB commands at build time. If any of the outputs change, CMake will regenerate the build system. By default GLOB lists directories - directories are omitted in result if LIST_DIRECTORIES is set to false. NOTE: We do not recommend using GLOB to collect a list of source files from your source tree. If no CMakeLists.txt file changes when a source is added or removed then the generated build system cannot know when to ask CMake to regenerate. The CONFIGURE_DEPENDS flag may not work reliably on all generators, or if a new generator is added in the future that cannot support it, projects using it will be stuck. Even if CONFIGURE_DE‐ PENDS works reliably, there is still a cost to perform the check on every rebuild. Examples of globbing expressions include: *.cxx - match all files with extension cxx *.vt? - match all files with extension vta,...,vtz f[3-5].txt - match files f3.txt, f4.txt, f5.txt The GLOB_RECURSE mode will traverse all the subdirectories of the matched directory and match the files. Subdirectories that are symlinks are only traversed if FOLLOW_SYMLINKS is given or policy CMP0009 is not set to NEW. By default GLOB_RECURSE omits directories from result list - setting LIST_DIRECTORIES to true adds directories to result list. If FOLLOW_SYMLINKS is given or policy CMP0009 is not set to OLD then LIST_DIRECTORIES treats symlinks as directories. Examples of recursive globbing include: /dir/*.py - match all python files in /dir and subdirectories file(RENAME <oldname> <newname>) Move a file or directory within a filesystem from <oldname> to <newname>, replacing the destination atomically. file(REMOVE [<files>...]) file(REMOVE_RECURSE [<files>...]) Remove the given files. The REMOVE_RECURSE mode will remove the given files and directories, also non-empty directories. No error is emitted if a given file does not exist. Relative input paths are evaluated with respect to the current source directory. Empty input paths are ignored with a warning. file(MAKE_DIRECTORY [<directories>...]) Create the given directories and their parents as needed. file(<COPY|INSTALL> <files>... DESTINATION <dir> [FILE_PERMISSIONS <permissions>...] [DIRECTORY_PERMISSIONS <permissions>...] [NO_SOURCE_PERMISSIONS] [USE_SOURCE_PERMISSIONS] [FOLLOW_SYMLINK_CHAIN] [FILES_MATCHING] [[PATTERN <pattern> | REGEX <regex>] [EXCLUDE] [PERMISSIONS <permissions>...]] [...]) The COPY signature copies files, directories, and symlinks to a destination folder. Relative input paths are evaluated with respect to the cur‐ rent source directory, and a relative destination is evaluated with respect to the current build directory. Copying preserves input file time‐ stamps, and optimizes out a file if it exists at the destination with the same timestamp. Copying preserves input permissions unless explicit permissions or NO_SOURCE_PERMISSIONS are given (default is USE_SOURCE_PERMISSIONS). If FOLLOW_SYMLINK_CHAIN is specified, COPY will recursively resolve the symlinks at the paths given until a real file is found, and install a cor‐ responding symlink in the destination for each symlink encountered. For each symlink that is installed, the resolution is stripped of the direc‐ tory, leaving only the filename, meaning that the new symlink points to a file in the same directory as the symlink. This feature is useful on some Unix systems, where libraries are installed as a chain of symlinks with version numbers, with less specific versions pointing to more spe‐ cific versions. FOLLOW_SYMLINK_CHAIN will install all of these symlinks and the library itself into the destination directory. For example, if you have the following directory structure: • /opt/foo/lib/libfoo.so.1.2.3 • /opt/foo/lib/libfoo.so.1.2 -> libfoo.so.1.2.3 • /opt/foo/lib/libfoo.so.1 -> libfoo.so.1.2 • /opt/foo/lib/libfoo.so -> libfoo.so.1 and you do: file(COPY /opt/foo/lib/libfoo.so DESTINATION lib FOLLOW_SYMLINK_CHAIN) This will install all of the symlinks and libfoo.so.1.2.3 itself into lib. See the install(DIRECTORY) command for documentation of permissions, FILES_MATCHING, PATTERN, REGEX, and EXCLUDE options. Copying directories preserves the structure of their content even if options are used to select a subset of files. The INSTALL signature differs slightly from COPY: it prints status messages (subject to the CMAKE_INSTALL_MESSAGE variable), and NO_SOURCE_PERMIS‐ SIONS is default. Installation scripts generated by the install() command use this signature (with some undocumented options for internal use). file(SIZE <filename> <variable>) Determine the file size of the <filename> and put the result in <variable> variable. Requires that <filename> is a valid path pointing to a file and is readable. file(READ_SYMLINK <linkname> <variable>) This subcommand queries the symlink <linkname> and stores the path it points to in the result <variable>. If <linkname> does not exist or is not a symlink, CMake issues a fatal error. Note that this command returns the raw symlink path and does not resolve a relative path. The following is an example of how to ensure that an absolute path is obtained: set(linkname /path/to/foo.sym) file(READ_SYMLINK ${linkname} result) if(NOT IS_ABSOLUTE ${result}) get_filename_component(dir ${linkname} DIRECTORY) set(result ${dir}/${result}) endif() file(CREATE_LINK <original> <linkname> [RESULT <result>] [COPY_ON_ERROR] [SYMBOLIC]) Create a link <linkname> that points to <original>. It will be a hard link by default, but providing the SYMBOLIC option results in a symbolic link instead. Hard links require that original exists and is a file, not a directory. If <linkname> already exists, it will be overwritten. The <result> variable, if specified, receives the status of the operation. It is set to 0 upon success or an error message otherwise. If RESULT is not specified and the operation fails, a fatal error is emitted. Specifying COPY_ON_ERROR enables copying the file as a fallback if creating the link fails. It can be useful for handling situations such as <original> and <linkname> being on different drives or mount points, which would make them unable to support a hard link. Path Conversion file(RELATIVE_PATH <variable> <directory> <file>) Compute the relative path from a <directory> to a <file> and store it in the <variable>. file(TO_CMAKE_PATH <path> <variable>) file(TO_NATIVE_PATH <path> <variable>) The TO_CMAKE_PATH mode converts a native <path> into a cmake-style path with forward-slashes (/). The input can be a single path or a system search path like $ENV{PATH}. A search path will be converted to a cmake-style list separated by ; characters. The TO_NATIVE_PATH mode converts a cmake-style <path> into a native path with platform-specific slashes ( on Windows and / elsewhere). Always use double quotes around the <path> to be sure it is treated as a single argument to this command. Transfer file(DOWNLOAD <url> <file> [<options>...]) file(UPLOAD <file> <url> [<options>...]) The DOWNLOAD mode downloads the given <url> to a local <file>. The UPLOAD mode uploads a local <file> to a given <url>. Options to both DOWNLOAD and UPLOAD are: INACTIVITY_TIMEOUT <seconds> Terminate the operation after a period of inactivity. LOG <variable> Store a human-readable log of the operation in a variable. SHOW_PROGRESS Print progress information as status messages until the operation is complete. STATUS <variable> Store the resulting status of the operation in a variable. The status is a ; separated list of length 2. The first element is the numeric return value for the operation, and the second element is a string value for the error. A 0 numeric error means no error in the operation. TIMEOUT <seconds> Terminate the operation after a given total time has elapsed. USERPWD <username>:<password> Set username and password for operation. HTTPHEADER <HTTP-header> HTTP header for operation. Suboption can be repeated several times. NETRC <level> Specify whether the .netrc file is to be used for operation. If this option is not specified, the value of the CMAKE_NETRC variable will be used instead. Valid levels are: IGNORED The .netrc file is ignored. This is the default. OPTIONAL The .netrc file is optional, and information in the URL is preferred. The file will be scanned to find which ever information is not specified in the URL. REQUIRED The .netrc file is required, and information in the URL is ignored. NETRC_FILE <file> Specify an alternative .netrc file to the one in your home directory, if the NETRC level is OPTIONAL or REQUIRED. If this option is not specified, the value of the CMAKE_NETRC_FILE variable will be used instead. If neither NETRC option is given CMake will check variables CMAKE_NETRC and CMAKE_NETRC_FILE, respectively. Additional options to DOWNLOAD are: EXPECTED_HASH ALGO=<value> Verify that the downloaded content hash matches the expected value, where ALGO is one of the algorithms supported by file(<HASH>). If it does not match, the operation fails with an error. EXPECTED_MD5 <value> Historical short-hand for EXPECTED_HASH MD5=<value>. TLS_VERIFY <ON|OFF> Specify whether to verify the server certificate for https:// URLs. The default is to not verify. TLS_CAINFO <file> Specify a custom Certificate Authority file for https:// URLs. For https:// URLs CMake must be built with OpenSSL support. TLS/SSL certificates are not checked by default. Set TLS_VERIFY to ON to check cer‐ tificates and/or use EXPECTED_HASH to verify downloaded content. If neither TLS option is given CMake will check variables CMAKE_TLS_VERIFY and CMAKE_TLS_CAINFO, respectively. Locking file(LOCK <path> [DIRECTORY] [RELEASE] [GUARD <FUNCTION|FILE|PROCESS>] [RESULT_VARIABLE <variable>] [TIMEOUT <seconds>]) Lock a file specified by <path> if no DIRECTORY option present and file <path>/cmake.lock otherwise. File will be locked for scope defined by GUARD option (default value is PROCESS). RELEASE option can be used to unlock file explicitly. If option TIMEOUT is not specified CMake will wait until lock succeed or until fatal error occurs. If TIMEOUT is set to 0 lock will be tried once and result will be reported immediately. If TIMEOUT is not 0 CMake will try to lock file for the period specified by <seconds> value. Any errors will be interpreted as fatal if there is no RE‐ SULT_VARIABLE option. Otherwise result will be stored in <variable> and will be 0 on success or error message on failure. Note that lock is advisory - there is no guarantee that other processes will respect this lock, i.e. lock synchronize two or more CMake instances sharing some modifiable resources. Similar logic applied to DIRECTORY option - locking parent directory doesn’t prevent other LOCK commands to lock any child directory or file. Trying to lock file twice is not allowed. Any intermediate directories and file itself will be created if they not exist. GUARD and TIMEOUT op‐ tions ignored on RELEASE operation. find_file A short-hand signature is: find_file (<VAR> name1 [path1 path2 ...]) The general signature is: find_file ( <VAR> name | NAMES name1 [name2 ...] [HINTS path1 [path2 ... ENV var]] [PATHS path1 [path2 ... ENV var]] [PATH_SUFFIXES suffix1 [suffix2 ...]] [DOC cache documentation string] [NO_DEFAULT_PATH] [NO_PACKAGE_ROOT_PATH] [NO_CMAKE_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_SYSTEM_PATH] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH] ) This command is used to find a full path to named file. A cache entry named by <VAR> is created to store the result of this command. If the full path to a file is found the result is stored in the variable and the search will not be repeated unless the variable is cleared. If nothing is found, the result will be <VAR>-NOTFOUND, and the search will be attempted again the next time find_file is invoked with the same variable. Options include: NAMES Specify one or more possible names for the full path to a file. When using this to specify names with and without a version suffix, we recommend specifying the unversioned name first so that lo‐ cally-built packages can be found before those provided by distributions. HINTS, PATHS Specify directories to search in addition to the default locations. The ENV var sub-option reads paths from a system environment variable. PATH_SUFFIXES Specify additional subdirectories to check below each directory location otherwise considered. DOC Specify the documentation string for the <VAR> cache entry. If NO_DEFAULT_PATH is specified, then no additional paths are added to the search. If NO_DEFAULT_PATH is not specified, the search process is as follows: 1. If called from within a find module or any other script loaded by a call to find_package(<PackageName>), search prefixes unique to the current package being found. Specifically, look in the <PackageName>_ROOT CMake variable and the <PackageName>_ROOT environment variable. The package root variables are maintained as a stack, so if called from nested find modules or config packages, root paths from the parent’s find module or config package will be searched after paths from the current module or package. In other words, the search order would be <CurrentPack‐ age>_ROOT, ENV{<CurrentPackage>_ROOT}, <ParentPackage>_ROOT, ENV{<ParentPackage>_ROOT}, etc. This can be skipped if NO_PACKAGE_ROOT_PATH is passed or by setting the CMAKE_FIND_USE_PACKAGE_ROOT_PATH to FALSE. See policy CMP0074. • <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and <prefix>/include for each <prefix> in the <PackageName>_ROOT CMake variable and the <PackageName>_ROOT environment variable if called from within a find module loaded by find_package(<PackageName>) 2. Search paths specified in cmake-specific cache variables. These are intended to be used on the command line with a -DVAR=value. The values are interpreted as semicolon-separated lists. This can be skipped if NO_CMAKE_PATH is passed or by setting the CMAKE_FIND_USE_CMAKE_PATH to FALSE. • <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and <prefix>/include for each <prefix> in CMAKE_PREFIX_PATH • CMAKE_INCLUDE_PATH • CMAKE_FRAMEWORK_PATH 3. Search paths specified in cmake-specific environment variables. These are intended to be set in the user’s shell configuration, and therefore use the host’s native path separator (; on Windows and : on UNIX). This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed or by setting the CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH to FALSE. • <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and <prefix>/include for each <prefix> in CMAKE_PREFIX_PATH • CMAKE_INCLUDE_PATH • CMAKE_FRAMEWORK_PATH 4. Search the paths specified by the HINTS option. These should be paths computed by system introspection, such as a hint provided by the loca‐ tion of another item already found. Hard-coded guesses should be specified with the PATHS option. 5. Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is passed or by setting the CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH to FALSE. • The directories in PATH and INCLUDE. • On Windows hosts: <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and <prefix>/include for each <prefix>/[s]bin in PATH, and <entry>/include for other entries in PATH. 6. Search cmake variables defined in the Platform files for the current system. This can be skipped if NO_CMAKE_SYSTEM_PATH is passed or by set‐ ting the CMAKE_FIND_USE_CMAKE_SYSTEM_PATH to FALSE. • <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and <prefix>/include for each <prefix> in CMAKE_SYSTEM_PREFIX_PATH • CMAKE_SYSTEM_INCLUDE_PATH • CMAKE_SYSTEM_FRAMEWORK_PATH 7. Search the paths specified by the PATHS option or in the short-hand version of the command. These are typically hard-coded guesses. On macOS the CMAKE_FIND_FRAMEWORK and CMAKE_FIND_APPBUNDLE variables determine the order of preference between Apple-style and unix-style package components. The CMake variable CMAKE_FIND_ROOT_PATH specifies one or more directories to be prepended to all other search directories. This effectively “re-roots” the entire search under given locations. Paths which are descendants of the CMAKE_STAGING_PREFIX are excluded from this re-rooting, because that variable is always a path on the host system. By default the CMAKE_FIND_ROOT_PATH is empty. The CMAKE_SYSROOT variable can also be used to specify exactly one directory to use as a prefix. Setting CMAKE_SYSROOT also has other effects. See the documentation for that variable for more. These variables are especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too. By default at first the directories listed in CMAKE_FIND_ROOT_PATH are searched, then the CMAKE_SYSROOT directory is searched, and then the non-rooted directories will be searched. The default behavior can be adjusted by setting CMAKE_FIND_ROOT_PATH_MODE_INCLUDE. This behavior can be manually overridden on a per-call basis using options: CMAKE_FIND_ROOT_PATH_BOTH Search in the order described above. NO_CMAKE_FIND_ROOT_PATH Do not use the CMAKE_FIND_ROOT_PATH variable. ONLY_CMAKE_FIND_ROOT_PATH Search only the re-rooted directories and directories below CMAKE_STAGING_PREFIX. The default search order is designed to be most-specific to least-specific for common use cases. Projects may override the order by simply call‐ ing the command multiple times and using the NO_* options: find_file (<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH) find_file (<VAR> NAMES name) Once one of the calls succeeds the result variable will be set and stored in the cache so that no call will search again. find_library A short-hand signature is: find_library (<VAR> name1 [path1 path2 ...]) The general signature is: find_library ( <VAR> name | NAMES name1 [name2 ...] [NAMES_PER_DIR] [HINTS path1 [path2 ... ENV var]] [PATHS path1 [path2 ... ENV var]] [PATH_SUFFIXES suffix1 [suffix2 ...]] [DOC cache documentation string] [NO_DEFAULT_PATH] [NO_PACKAGE_ROOT_PATH] [NO_CMAKE_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_SYSTEM_PATH] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH] ) This command is used to find a library. A cache entry named by <VAR> is created to store the result of this command. If the library is found the result is stored in the variable and the search will not be repeated unless the variable is cleared. If nothing is found, the result will be <VAR>-NOTFOUND, and the search will be attempted again the next time find_library is invoked with the same variable. Options include: NAMES Specify one or more possible names for the library. When using this to specify names with and without a version suffix, we recommend specifying the unversioned name first so that lo‐ cally-built packages can be found before those provided by distributions. HINTS, PATHS Specify directories to search in addition to the default locations. The ENV var sub-option reads paths from a system environment variable. PATH_SUFFIXES Specify additional subdirectories to check below each directory location otherwise considered. DOC Specify the documentation string for the <VAR> cache entry. If NO_DEFAULT_PATH is specified, then no additional paths are added to the search. If NO_DEFAULT_PATH is not specified, the search process is as follows: 1. If called from within a find module or any other script loaded by a call to find_package(<PackageName>), search prefixes unique to the current package being found. Specifically, look in the <PackageName>_ROOT CMake variable and the <PackageName>_ROOT environment variable. The package root variables are maintained as a stack, so if called from nested find modules or config packages, root paths from the parent’s find module or config package will be searched after paths from the current module or package. In other words, the search order would be <CurrentPack‐ age>_ROOT, ENV{<CurrentPackage>_ROOT}, <ParentPackage>_ROOT, ENV{<ParentPackage>_ROOT}, etc. This can be skipped if NO_PACKAGE_ROOT_PATH is passed or by setting the CMAKE_FIND_USE_PACKAGE_ROOT_PATH to FALSE. See policy CMP0074. • <prefix>/lib/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and <prefix>/lib for each <prefix> in the <PackageName>_ROOT CMake variable and the <PackageName>_ROOT environment variable if called from within a find module loaded by find_package(<PackageName>) 2. Search paths specified in cmake-specific cache variables. These are intended to be used on the command line with a -DVAR=value. The values are interpreted as semicolon-separated lists. This can be skipped if NO_CMAKE_PATH is passed or by setting the CMAKE_FIND_USE_CMAKE_PATH to FALSE. • <prefix>/lib/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and <prefix>/lib for each <prefix> in CMAKE_PREFIX_PATH • CMAKE_LIBRARY_PATH • CMAKE_FRAMEWORK_PATH 3. Search paths specified in cmake-specific environment variables. These are intended to be set in the user’s shell configuration, and therefore use the host’s native path separator (; on Windows and : on UNIX). This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed or by setting the CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH to FALSE. • <prefix>/lib/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and <prefix>/lib for each <prefix> in CMAKE_PREFIX_PATH • CMAKE_LIBRARY_PATH • CMAKE_FRAMEWORK_PATH 4. Search the paths specified by the HINTS option. These should be paths computed by system introspection, such as a hint provided by the loca‐ tion of another item already found. Hard-coded guesses should be specified with the PATHS option. 5. Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is passed or by setting the CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH to FALSE. • The directories in PATH and INCLUDE. • On Windows hosts: <prefix>/lib/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and <prefix>/lib for each <prefix>/[s]bin in PATH, and <en‐ try>/lib for other entries in PATH. 6. Search cmake variables defined in the Platform files for the current system. This can be skipped if NO_CMAKE_SYSTEM_PATH is passed or by set‐ ting the CMAKE_FIND_USE_CMAKE_SYSTEM_PATH to FALSE. • <prefix>/lib/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and <prefix>/lib for each <prefix> in CMAKE_SYSTEM_PREFIX_PATH • CMAKE_SYSTEM_LIBRARY_PATH • CMAKE_SYSTEM_FRAMEWORK_PATH 7. Search the paths specified by the PATHS option or in the short-hand version of the command. These are typically hard-coded guesses. On macOS the CMAKE_FIND_FRAMEWORK and CMAKE_FIND_APPBUNDLE variables determine the order of preference between Apple-style and unix-style package components. The CMake variable CMAKE_FIND_ROOT_PATH specifies one or more directories to be prepended to all other search directories. This effectively “re-roots” the entire search under given locations. Paths which are descendants of the CMAKE_STAGING_PREFIX are excluded from this re-rooting, because that variable is always a path on the host system. By default the CMAKE_FIND_ROOT_PATH is empty. The CMAKE_SYSROOT variable can also be used to specify exactly one directory to use as a prefix. Setting CMAKE_SYSROOT also has other effects. See the documentation for that variable for more. These variables are especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too. By default at first the directories listed in CMAKE_FIND_ROOT_PATH are searched, then the CMAKE_SYSROOT directory is searched, and then the non-rooted directories will be searched. The default behavior can be adjusted by setting CMAKE_FIND_ROOT_PATH_MODE_LIBRARY. This behavior can be manually overridden on a per-call basis using options: CMAKE_FIND_ROOT_PATH_BOTH Search in the order described above. NO_CMAKE_FIND_ROOT_PATH Do not use the CMAKE_FIND_ROOT_PATH variable. ONLY_CMAKE_FIND_ROOT_PATH Search only the re-rooted directories and directories below CMAKE_STAGING_PREFIX. The default search order is designed to be most-specific to least-specific for common use cases. Projects may override the order by simply call‐ ing the command multiple times and using the NO_* options: find_library (<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH) find_library (<VAR> NAMES name) Once one of the calls succeeds the result variable will be set and stored in the cache so that no call will search again. When more than one value is given to the NAMES option this command by default will consider one name at a time and search every directory for it. The NAMES_PER_DIR option tells this command to consider one directory at a time and search for all names in it. Each library name given to the NAMES option is first considered as a library file name and then considered with platform-specific prefixes (e.g. lib) and suffixes (e.g. .so). Therefore one may specify library file names such as libfoo.a directly. This can be used to locate static li‐ braries on UNIX-like systems. If the library found is a framework, then <VAR> will be set to the full path to the framework <fullPath>/A.framework. When a full path to a framework is used as a library, CMake will use a -framework A, and a -F<fullPath> to link the framework to the target. If the CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX variable is set all search paths will be tested as normal, with the suffix appended, and with all matches of lib/ replaced with lib${CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX}/. This variable overrides the FIND_LIBRARY_USE_LIB32_PATHS, FIND_LI‐ BRARY_USE_LIBX32_PATHS, and FIND_LIBRARY_USE_LIB64_PATHS global properties. If the FIND_LIBRARY_USE_LIB32_PATHS global property is set all search paths will be tested as normal, with 32/ appended, and with all matches of lib/ replaced with lib32/. This property is automatically set for the platforms that are known to need it if at least one of the languages sup‐ ported by the project() command is enabled. If the FIND_LIBRARY_USE_LIBX32_PATHS global property is set all search paths will be tested as normal, with x32/ appended, and with all matches of lib/ replaced with libx32/. This property is automatically set for the platforms that are known to need it if at least one of the languages sup‐ ported by the project() command is enabled. If the FIND_LIBRARY_USE_LIB64_PATHS global property is set all search paths will be tested as normal, with 64/ appended, and with all matches of lib/ replaced with lib64/. This property is automatically set for the platforms that are known to need it if at least one of the languages sup‐ ported by the project() command is enabled. find_package Find an external project, and load its settings. Basic Signature and Module Mode find_package(<PackageName> [version] [EXACT] [QUIET] [MODULE] [REQUIRED] [[COMPONENTS] [components...]] [OPTIONAL_COMPONENTS components...] [NO_POLICY_SCOPE]) Finds and loads settings from an external project. <PackageName>_FOUND will be set to indicate whether the package was found. When the package is found package-specific information is provided through variables and Imported Targets documented by the package itself. The QUIET option dis‐ ables informational messages, including those indicating that the package cannot be found if it is not REQUIRED. The REQUIRED option stops pro‐ cessing with an error message if the package cannot be found. A package-specific list of required components may be listed after the COMPONENTS option (or after the REQUIRED option if present). Additional optional components may be listed after OPTIONAL_COMPONENTS. Available components and their influence on whether a package is considered to be found are defined by the target package. The [version] argument requests a version with which the package found should be compatible (format is major[.minor[.patch[.tweak]]]). The EXACT option requests that the version be matched exactly. If no [version] and/or component list is given to a recursive invocation inside a find-mod‐ ule, the corresponding arguments are forwarded automatically from the outer call (including the EXACT flag for [version]). Version support is currently provided only on a package-by-package basis (see the Version Selection section below). See the cmake_policy() command documentation for discussion of the NO_POLICY_SCOPE option. The command has two modes by which it searches for packages: “Module” mode and “Config” mode. The above signature selects Module mode. If no module is found the command falls back to Config mode, described below. This fall back is disabled if the MODULE option is given. In Module mode, CMake searches for a file called Find<PackageName>.cmake. The file is first searched in the CMAKE_MODULE_PATH, then among the Find Modules provided by the CMake installation. If the file is found, it is read and processed by CMake. It is responsible for finding the package, checking the version, and producing any needed messages. Some find-modules provide limited or no support for versioning; check the mod‐ ule documentation. If the MODULE option is not specfied in the above signature, CMake first searches for the package using Module mode. Then, if the package is not found, it searches again using Config mode. A user may set the variable CMAKE_FIND_PACKAGE_PREFER_CONFIG to TRUE to direct CMake first search us‐ ing Config mode before falling back to Module mode. Full Signature and Config Mode User code should generally look for packages using the above basic signature. The remainder of this command documentation specifies the full com‐ mand signature and details of the search process. Project maintainers wishing to provide a package to be found by this command are encouraged to read on. The complete Config mode command signature is find_package(<PackageName> [version] [EXACT] [QUIET] [REQUIRED] [[COMPONENTS] [components...]] [OPTIONAL_COMPONENTS components...] [CONFIG|NO_MODULE] [NO_POLICY_SCOPE] [NAMES name1 [name2 ...]] [CONFIGS config1 [config2 ...]] [HINTS path1 [path2 ... ]] [PATHS path1 [path2 ... ]] [PATH_SUFFIXES suffix1 [suffix2 ...]] [NO_DEFAULT_PATH] [NO_PACKAGE_ROOT_PATH] [NO_CMAKE_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_PACKAGE_REGISTRY] [NO_CMAKE_BUILDS_PATH] # Deprecated; does nothing. [NO_CMAKE_SYSTEM_PATH] [NO_CMAKE_SYSTEM_PACKAGE_REGISTRY] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH]) The CONFIG option, the synonymous NO_MODULE option, or the use of options not specified in the basic signature all enforce pure Config mode. In pure Config mode, the command skips Module mode search and proceeds at once with Config mode search. Config mode search attempts to locate a configuration file provided by the package to be found. A cache entry called <PackageName>_DIR is created to hold the directory containing the file. By default the command searches for a package with the name <PackageName>. If the NAMES option is given the names following it are used instead of <PackageName>. The command searches for a file called <PackageName>Config.cmake or <lower-case-package-name>-config.cmake for each name specified. A replacement set of possible configuration file names may be given using the CONFIGS option. The search procedure is specified below. Once found, the configuration file is read and processed by CMake. Since the file is provided by the package it already knows the location of package contents. The full path to the configuration file is stored in the cmake vari‐ able <PackageName>_CONFIG. All configuration files which have been considered by CMake while searching for an installation of the package with an appropriate version are stored in the cmake variable <PackageName>_CONSIDERED_CONFIGS, the associated versions in <PackageName>_CONSIDERED_VERSIONS. If the package configuration file cannot be found CMake will generate an error describing the problem unless the QUIET argument is specified. If REQUIRED is specified and the package is not found a fatal error is generated and the configure step stops executing. If <PackageName>_DIR has been set to a directory not containing a configuration file CMake will ignore it and search from scratch. Package maintainers providing CMake package configuration files are encouraged to name and install them such that the Search Procedure outlined below will find them without requiring use of additional options. Version Selection When the [version] argument is given Config mode will only find a version of the package that claims compatibility with the requested version (format is major[.minor[.patch[.tweak]]]). If the EXACT option is given only a version of the package claiming an exact match of the requested version may be found. CMake does not establish any convention for the meaning of version numbers. Package version numbers are checked by “ver‐ sion” files provided by the packages themselves. For a candidate package configuration file <config-file>.cmake the corresponding version file is located next to it and named either <config-file>-version.cmake or <config-file>Version.cmake. If no such version file is available then the con‐ figuration file is assumed to not be compatible with any requested version. A basic version file containing generic version matching code can be created using the CMakePackageConfigHelpers module. When a version file is found it is loaded to check the requested version number. The version file is loaded in a nested scope in which the following variables have been defined: PACKAGE_FIND_NAME the <PackageName> PACKAGE_FIND_VERSION full requested version string PACKAGE_FIND_VERSION_MAJOR major version if requested, else 0 PACKAGE_FIND_VERSION_MINOR minor version if requested, else 0 PACKAGE_FIND_VERSION_PATCH patch version if requested, else 0 PACKAGE_FIND_VERSION_TWEAK tweak version if requested, else 0 PACKAGE_FIND_VERSION_COUNT number of version components, 0 to 4 The version file checks whether it satisfies the requested version and sets these variables: PACKAGE_VERSION full provided version string PACKAGE_VERSION_EXACT true if version is exact match PACKAGE_VERSION_COMPATIBLE true if version is compatible PACKAGE_VERSION_UNSUITABLE true if unsuitable as any version These variables are checked by the find_package command to determine whether the configuration file provides an acceptable version. They are not available after the find_package call returns. If the version is acceptable the following variables are set: <PackageName>_VERSION full provided version string <PackageName>_VERSION_MAJOR major version if provided, else 0 <PackageName>_VERSION_MINOR minor version if provided, else 0 <PackageName>_VERSION_PATCH patch version if provided, else 0 <PackageName>_VERSION_TWEAK tweak version if provided, else 0 <PackageName>_VERSION_COUNT number of version components, 0 to 4 and the corresponding package configuration file is loaded. When multiple package configuration files are available whose version files claim compatibility with the version requested it is unspecified which one is chosen: unless the variable CMAKE_FIND_PACKAGE_SORT_ORDER is set no at‐ tempt is made to choose a highest or closest version number. To control the order in which find_package checks for compatibility use the two variables CMAKE_FIND_PACKAGE_SORT_ORDER and CMAKE_FIND_PACK‐ AGE_SORT_DIRECTION. For instance in order to select the highest version one can set SET(CMAKE_FIND_PACKAGE_SORT_ORDER NATURAL) SET(CMAKE_FIND_PACKAGE_SORT_DIRECTION DEC) before calling find_package. Search Procedure CMake constructs a set of possible installation prefixes for the package. Under each prefix several directories are searched for a configuration file. The tables below show the directories searched. Each entry is meant for installation trees following Windows (W), UNIX (U), or Apple (A) conventions: <prefix>/ (W) <prefix>/(cmake|CMake)/ (W) <prefix>/<name>*/ (W) <prefix>/<name>*/(cmake|CMake)/ (W) <prefix>/(lib/<arch>|lib*|share)/cmake/<name>*/ (U) <prefix>/(lib/<arch>|lib*|share)/<name>*/ (U) <prefix>/(lib/<arch>|lib*|share)/<name>*/(cmake|CMake)/ (U) <prefix>/<name>*/(lib/<arch>|lib*|share)/cmake/<name>*/ (W/U) <prefix>/<name>*/(lib/<arch>|lib*|share)/<name>*/ (W/U) <prefix>/<name>*/(lib/<arch>|lib*|share)/<name>*/(cmake|CMake)/ (W/U) On systems supporting macOS FRAMEWORK and BUNDLE, the following directories are searched for Frameworks or Application Bundles containing a con‐ figuration file: <prefix>/<name>.framework/Resources/ (A) <prefix>/<name>.framework/Resources/CMake/ (A) <prefix>/<name>.framework/Versions/*/Resources/ (A) <prefix>/<name>.framework/Versions/*/Resources/CMake/ (A) <prefix>/<name>.app/Contents/Resources/ (A) <prefix>/<name>.app/Contents/Resources/CMake/ (A) In all cases the <name> is treated as case-insensitive and corresponds to any of the names specified (<PackageName> or names given by NAMES). Paths with lib/<arch> are enabled if the CMAKE_LIBRARY_ARCHITECTURE variable is set. lib* includes one or more of the values lib64, lib32, libx32 or lib (searched in that order). • Paths with lib64 are searched on 64 bit platforms if the FIND_LIBRARY_USE_LIB64_PATHS property is set to TRUE. • Paths with lib32 are searched on 32 bit platforms if the FIND_LIBRARY_USE_LIB32_PATHS property is set to TRUE. • Paths with libx32 are searched on platforms using the x32 ABI if the FIND_LIBRARY_USE_LIBX32_PATHS property is set to TRUE. • The lib path is always searched. If PATH_SUFFIXES is specified, the suffixes are appended to each (W) or (U) directory entry one-by-one. This set of directories is intended to work in cooperation with projects that provide configuration files in their installation trees. Directo‐ ries above marked with (W) are intended for installations on Windows where the prefix may point at the top of an application’s installation direc‐ tory. Those marked with (U) are intended for installations on UNIX platforms where the prefix is shared by multiple packages. This is merely a convention, so all (W) and (U) directories are still searched on all platforms. Directories marked with (A) are intended for installations on Ap‐ ple platforms. The CMAKE_FIND_FRAMEWORK and CMAKE_FIND_APPBUNDLE variables determine the order of preference. The set of installation prefixes is constructed using the following steps. If NO_DEFAULT_PATH is specified all NO_* options are enabled. 1. Search paths specified in the <PackageName>_ROOT CMake variable and the <PackageName>_ROOT environment variable, where <PackageName> is the package to be found. The package root variables are maintained as a stack so if called from within a find module, root paths from the parent’s find module will also be searched after paths for the current package. This can be skipped if NO_PACKAGE_ROOT_PATH is passed or by setting the CMAKE_FIND_USE_PACKAGE_ROOT_PATH to FALSE. See policy CMP0074. 2. Search paths specified in cmake-specific cache variables. These are intended to be used on the command line with a -DVAR=value. The values are interpreted as semicolon-separated lists. This can be skipped if NO_CMAKE_PATH is passed or by setting the CMAKE_FIND_USE_CMAKE_PATH to FALSE: CMAKE_PREFIX_PATH CMAKE_FRAMEWORK_PATH CMAKE_APPBUNDLE_PATH 3. Search paths specified in cmake-specific environment variables. These are intended to be set in the user’s shell configuration, and therefore use the host’s native path separator (; on Windows and : on UNIX). This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed or by setting the CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH to FALSE: <PackageName>_DIR CMAKE_PREFIX_PATH CMAKE_FRAMEWORK_PATH CMAKE_APPBUNDLE_PATH 4. Search paths specified by the HINTS option. These should be paths computed by system introspection, such as a hint provided by the location of another item already found. Hard-coded guesses should be specified with the PATHS option. 5. Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is passed or by setting the CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH to FALSE. Path entries ending in /bin or /sbin are automatically converted to their parent directories: PATH 6. Search paths stored in the CMake User Package Registry. This can be skipped if NO_CMAKE_PACKAGE_REGISTRY is passed or by setting the variable CMAKE_FIND_USE_PACKAGE_REGISTRY to FALSE or the deprecated variable CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY to TRUE. See the cmake-packages(7) manual for details on the user package registry. 7. Search cmake variables defined in the Platform files for the current system. This can be skipped if NO_CMAKE_SYSTEM_PATH is passed or by set‐ ting the CMAKE_FIND_USE_CMAKE_SYSTEM_PATH to FALSE: CMAKE_SYSTEM_PREFIX_PATH CMAKE_SYSTEM_FRAMEWORK_PATH CMAKE_SYSTEM_APPBUNDLE_PATH 8. Search paths stored in the CMake System Package Registry. This can be skipped if NO_CMAKE_SYSTEM_PACKAGE_REGISTRY is passed or by setting the CMAKE_FIND_USE_SYSTEM_PACKAGE_REGISTRY variable to FALSE or the deprecated variable CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY to TRUE. See the cmake-packages(7) manual for details on the system package registry. 9. Search paths specified by the PATHS option. These are typically hard-coded guesses. The CMake variable CMAKE_FIND_ROOT_PATH specifies one or more directories to be prepended to all other search directories. This effectively “re-roots” the entire search under given locations. Paths which are descendants of the CMAKE_STAGING_PREFIX are excluded from this re-rooting, because that variable is always a path on the host system. By default the CMAKE_FIND_ROOT_PATH is empty. The CMAKE_SYSROOT variable can also be used to specify exactly one directory to use as a prefix. Setting CMAKE_SYSROOT also has other effects. See the documentation for that variable for more. These variables are especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too. By default at first the directories listed in CMAKE_FIND_ROOT_PATH are searched, then the CMAKE_SYSROOT directory is searched, and then the non-rooted directories will be searched. The default behavior can be adjusted by setting CMAKE_FIND_ROOT_PATH_MODE_PACKAGE. This behavior can be manually overridden on a per-call basis using options: CMAKE_FIND_ROOT_PATH_BOTH Search in the order described above. NO_CMAKE_FIND_ROOT_PATH Do not use the CMAKE_FIND_ROOT_PATH variable. ONLY_CMAKE_FIND_ROOT_PATH Search only the re-rooted directories and directories below CMAKE_STAGING_PREFIX. The default search order is designed to be most-specific to least-specific for common use cases. Projects may override the order by simply call‐ ing the command multiple times and using the NO_* options: find_package (<PackageName> PATHS paths... NO_DEFAULT_PATH) find_package (<PackageName>) Once one of the calls succeeds the result variable will be set and stored in the cache so that no call will search again. By default the value stored in the result variable will be the path at which the file is found. The CMAKE_FIND_PACKAGE_RESOLVE_SYMLINKS variable may be set to TRUE before calling find_package in order to resolve symbolic links and store the real path to the file. Every non-REQUIRED find_package call can be disabled by setting the CMAKE_DISABLE_FIND_PACKAGE_<PackageName> variable to TRUE. Package File Interface Variables When loading a find module or package configuration file find_package defines variables to provide information about the call arguments (and re‐ stores their original state before returning): CMAKE_FIND_PACKAGE_NAME the <PackageName> which is searched for <PackageName>_FIND_REQUIRED true if REQUIRED option was given <PackageName>_FIND_QUIETLY true if QUIET option was given <PackageName>_FIND_VERSION full requested version string <PackageName>_FIND_VERSION_MAJOR major version if requested, else 0 <PackageName>_FIND_VERSION_MINOR minor version if requested, else 0 <PackageName>_FIND_VERSION_PATCH patch version if requested, else 0 <PackageName>_FIND_VERSION_TWEAK tweak version if requested, else 0 <PackageName>_FIND_VERSION_COUNT number of version components, 0 to 4 <PackageName>_FIND_VERSION_EXACT true if EXACT option was given <PackageName>_FIND_COMPONENTS list of requested components <PackageName>_FIND_REQUIRED_<c> true if component <c> is required, false if component <c> is optional In Module mode the loaded find module is responsible to honor the request detailed by these variables; see the find module for details. In Config mode find_package handles REQUIRED, QUIET, and [version] options automatically but leaves it to the package configuration file to handle compo‐ nents in a way that makes sense for the package. The package configuration file may set <PackageName>_FOUND to false to tell find_package that component requirements are not satisfied. find_path A short-hand signature is: find_path (<VAR> name1 [path1 path2 ...]) The general signature is: find_path ( <VAR> name | NAMES name1 [name2 ...] [HINTS path1 [path2 ... ENV var]] [PATHS path1 [path2 ... ENV var]] [PATH_SUFFIXES suffix1 [suffix2 ...]] [DOC cache documentation string] [NO_DEFAULT_PATH] [NO_PACKAGE_ROOT_PATH] [NO_CMAKE_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_SYSTEM_PATH] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH] ) This command is used to find a directory containing the named file. A cache entry named by <VAR> is created to store the result of this command. If the file in a directory is found the result is stored in the variable and the search will not be repeated unless the variable is cleared. If nothing is found, the result will be <VAR>-NOTFOUND, and the search will be attempted again the next time find_path is invoked with the same vari‐ able. Options include: NAMES Specify one or more possible names for the file in a directory. When using this to specify names with and without a version suffix, we recommend specifying the unversioned name first so that lo‐ cally-built packages can be found before those provided by distributions. HINTS, PATHS Specify directories to search in addition to the default locations. The ENV var sub-option reads paths from a system environment variable. PATH_SUFFIXES Specify additional subdirectories to check below each directory location otherwise considered. DOC Specify the documentation string for the <VAR> cache entry. If NO_DEFAULT_PATH is specified, then no additional paths are added to the search. If NO_DEFAULT_PATH is not specified, the search process is as follows: 1. If called from within a find module or any other script loaded by a call to find_package(<PackageName>), search prefixes unique to the current package being found. Specifically, look in the <PackageName>_ROOT CMake variable and the <PackageName>_ROOT environment variable. The package root variables are maintained as a stack, so if called from nested find modules or config packages, root paths from the parent’s find module or config package will be searched after paths from the current module or package. In other words, the search order would be <CurrentPack‐ age>_ROOT, ENV{<CurrentPackage>_ROOT}, <ParentPackage>_ROOT, ENV{<ParentPackage>_ROOT}, etc. This can be skipped if NO_PACKAGE_ROOT_PATH is passed or by setting the CMAKE_FIND_USE_PACKAGE_ROOT_PATH to FALSE. See policy CMP0074. • <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and <prefix>/include for each <prefix> in the <PackageName>_ROOT CMake variable and the <PackageName>_ROOT environment variable if called from within a find module loaded by find_package(<PackageName>) 2. Search paths specified in cmake-specific cache variables. These are intended to be used on the command line with a -DVAR=value. The values are interpreted as semicolon-separated lists. This can be skipped if NO_CMAKE_PATH is passed or by setting the CMAKE_FIND_USE_CMAKE_PATH to FALSE. • <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and <prefix>/include for each <prefix> in CMAKE_PREFIX_PATH • CMAKE_INCLUDE_PATH • CMAKE_FRAMEWORK_PATH 3. Search paths specified in cmake-specific environment variables. These are intended to be set in the user’s shell configuration, and therefore use the host’s native path separator (; on Windows and : on UNIX). This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed or by setting the CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH to FALSE. • <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and <prefix>/include for each <prefix> in CMAKE_PREFIX_PATH • CMAKE_INCLUDE_PATH • CMAKE_FRAMEWORK_PATH 4. Search the paths specified by the HINTS option. These should be paths computed by system introspection, such as a hint provided by the loca‐ tion of another item already found. Hard-coded guesses should be specified with the PATHS option. 5. Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is passed or by setting the CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH to FALSE. • The directories in PATH and INCLUDE. • On Windows hosts: <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and <prefix>/include for each <prefix>/[s]bin in PATH, and <entry>/include for other entries in PATH. 6. Search cmake variables defined in the Platform files for the current system. This can be skipped if NO_CMAKE_SYSTEM_PATH is passed or by set‐ ting the CMAKE_FIND_USE_CMAKE_SYSTEM_PATH to FALSE. • <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and <prefix>/include for each <prefix> in CMAKE_SYSTEM_PREFIX_PATH • CMAKE_SYSTEM_INCLUDE_PATH • CMAKE_SYSTEM_FRAMEWORK_PATH 7. Search the paths specified by the PATHS option or in the short-hand version of the command. These are typically hard-coded guesses. On macOS the CMAKE_FIND_FRAMEWORK and CMAKE_FIND_APPBUNDLE variables determine the order of preference between Apple-style and unix-style package components. The CMake variable CMAKE_FIND_ROOT_PATH specifies one or more directories to be prepended to all other search directories. This effectively “re-roots” the entire search under given locations. Paths which are descendants of the CMAKE_STAGING_PREFIX are excluded from this re-rooting, because that variable is always a path on the host system. By default the CMAKE_FIND_ROOT_PATH is empty. The CMAKE_SYSROOT variable can also be used to specify exactly one directory to use as a prefix. Setting CMAKE_SYSROOT also has other effects. See the documentation for that variable for more. These variables are especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too. By default at first the directories listed in CMAKE_FIND_ROOT_PATH are searched, then the CMAKE_SYSROOT directory is searched, and then the non-rooted directories will be searched. The default behavior can be adjusted by setting CMAKE_FIND_ROOT_PATH_MODE_INCLUDE. This behavior can be manually overridden on a per-call basis using options: CMAKE_FIND_ROOT_PATH_BOTH Search in the order described above. NO_CMAKE_FIND_ROOT_PATH Do not use the CMAKE_FIND_ROOT_PATH variable. ONLY_CMAKE_FIND_ROOT_PATH Search only the re-rooted directories and directories below CMAKE_STAGING_PREFIX. The default search order is designed to be most-specific to least-specific for common use cases. Projects may override the order by simply call‐ ing the command multiple times and using the NO_* options: find_path (<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH) find_path (<VAR> NAMES name) Once one of the calls succeeds the result variable will be set and stored in the cache so that no call will search again. When searching for frameworks, if the file is specified as A/b.h, then the framework search will look for A.framework/Headers/b.h. If that is found the path will be set to the path to the framework. CMake will convert this to the correct -F option to include the file. find_program A short-hand signature is: find_program (<VAR> name1 [path1 path2 ...]) The general signature is: find_program ( <VAR> name | NAMES name1 [name2 ...] [NAMES_PER_DIR] [HINTS path1 [path2 ... ENV var]] [PATHS path1 [path2 ... ENV var]] [PATH_SUFFIXES suffix1 [suffix2 ...]] [DOC cache documentation string] [NO_DEFAULT_PATH] [NO_PACKAGE_ROOT_PATH] [NO_CMAKE_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_SYSTEM_PATH] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH] ) This command is used to find a program. A cache entry named by <VAR> is created to store the result of this command. If the program is found the result is stored in the variable and the search will not be repeated unless the variable is cleared. If nothing is found, the result will be <VAR>-NOTFOUND, and the search will be attempted again the next time find_program is invoked with the same variable. Options include: NAMES Specify one or more possible names for the program. When using this to specify names with and without a version suffix, we recommend specifying the unversioned name first so that lo‐ cally-built packages can be found before those provided by distributions. HINTS, PATHS Specify directories to search in addition to the default locations. The ENV var sub-option reads paths from a system environment variable. PATH_SUFFIXES Specify additional subdirectories to check below each directory location otherwise considered. DOC Specify the documentation string for the <VAR> cache entry. If NO_DEFAULT_PATH is specified, then no additional paths are added to the search. If NO_DEFAULT_PATH is not specified, the search process is as follows: 1. If called from within a find module or any other script loaded by a call to find_package(<PackageName>), search prefixes unique to the current package being found. Specifically, look in the <PackageName>_ROOT CMake variable and the <PackageName>_ROOT environment variable. The package root variables are maintained as a stack, so if called from nested find modules or config packages, root paths from the parent’s find module or config package will be searched after paths from the current module or package. In other words, the search order would be <CurrentPack‐ age>_ROOT, ENV{<CurrentPackage>_ROOT}, <ParentPackage>_ROOT, ENV{<ParentPackage>_ROOT}, etc. This can be skipped if NO_PACKAGE_ROOT_PATH is passed or by setting the CMAKE_FIND_USE_PACKAGE_ROOT_PATH to FALSE. See policy CMP0074. • <prefix>/[s]bin for each <prefix> in the <PackageName>_ROOT CMake variable and the <PackageName>_ROOT environment variable if called from within a find module loaded by find_package(<PackageName>) 2. Search paths specified in cmake-specific cache variables. These are intended to be used on the command line with a -DVAR=value. The values are interpreted as semicolon-separated lists. This can be skipped if NO_CMAKE_PATH is passed or by setting the CMAKE_FIND_USE_CMAKE_PATH to FALSE. • <prefix>/[s]bin for each <prefix> in CMAKE_PREFIX_PATH • CMAKE_PROGRAM_PATH • CMAKE_APPBUNDLE_PATH 3. Search paths specified in cmake-specific environment variables. These are intended to be set in the user’s shell configuration, and therefore use the host’s native path separator (; on Windows and : on UNIX). This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed or by setting the CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH to FALSE. • <prefix>/[s]bin for each <prefix> in CMAKE_PREFIX_PATH • CMAKE_PROGRAM_PATH • CMAKE_APPBUNDLE_PATH 4. Search the paths specified by the HINTS option. These should be paths computed by system introspection, such as a hint provided by the loca‐ tion of another item already found. Hard-coded guesses should be specified with the PATHS option. 5. Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is passed or by setting the CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH to FALSE. • The directories in PATH itself. • On Windows hosts no extra search paths are included 6. Search cmake variables defined in the Platform files for the current system. This can be skipped if NO_CMAKE_SYSTEM_PATH is passed or by set‐ ting the CMAKE_FIND_USE_CMAKE_SYSTEM_PATH to FALSE. • <prefix>/[s]bin for each <prefix> in CMAKE_SYSTEM_PREFIX_PATH • CMAKE_SYSTEM_PROGRAM_PATH • CMAKE_SYSTEM_APPBUNDLE_PATH 7. Search the paths specified by the PATHS option or in the short-hand version of the command. These are typically hard-coded guesses. On macOS the CMAKE_FIND_FRAMEWORK and CMAKE_FIND_APPBUNDLE variables determine the order of preference between Apple-style and unix-style package components. The CMake variable CMAKE_FIND_ROOT_PATH specifies one or more directories to be prepended to all other search directories. This effectively “re-roots” the entire search under given locations. Paths which are descendants of the CMAKE_STAGING_PREFIX are excluded from this re-rooting, because that variable is always a path on the host system. By default the CMAKE_FIND_ROOT_PATH is empty. The CMAKE_SYSROOT variable can also be used to specify exactly one directory to use as a prefix. Setting CMAKE_SYSROOT also has other effects. See the documentation for that variable for more. These variables are especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too. By default at first the directories listed in CMAKE_FIND_ROOT_PATH are searched, then the CMAKE_SYSROOT directory is searched, and then the non-rooted directories will be searched. The default behavior can be adjusted by setting CMAKE_FIND_ROOT_PATH_MODE_PROGRAM. This behavior can be manually overridden on a per-call basis using options: CMAKE_FIND_ROOT_PATH_BOTH Search in the order described above. NO_CMAKE_FIND_ROOT_PATH Do not use the CMAKE_FIND_ROOT_PATH variable. ONLY_CMAKE_FIND_ROOT_PATH Search only the re-rooted directories and directories below CMAKE_STAGING_PREFIX. The default search order is designed to be most-specific to least-specific for common use cases. Projects may override the order by simply call‐ ing the command multiple times and using the NO_* options: find_program (<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH) find_program (<VAR> NAMES name) Once one of the calls succeeds the result variable will be set and stored in the cache so that no call will search again. When more than one value is given to the NAMES option this command by default will consider one name at a time and search every directory for it. The NAMES_PER_DIR option tells this command to consider one directory at a time and search for all names in it. foreach Evaluate a group of commands for each value in a list. foreach(<loop_var> <items>) <commands> endforeach() where <items> is a list of items that are separated by semicolon or whitespace. All commands between foreach and the matching endforeach are recorded without being invoked. Once the endforeach is evaluated, the recorded list of commands is invoked once for each item in <items>. At the beginning of each iteration the variable loop_var will be set to the value of the current item. The commands break() and continue() provide means to escape from the normal control flow. Per legacy, the endforeach() command admits an optional <loop_var> argument. If used, it must be a verbatim repeat of the argument of the opening foreach command. foreach(<loop_var> RANGE <stop>) In this variant, foreach iterates over the numbers 0, 1, … up to (and including) the nonnegative integer <stop>. foreach(<loop_var> RANGE <start> <stop> [<step>]) In this variant, foreach iterates over the numbers from <start> up to at most <stop> in steps of <step>. If <step> is not specified, then the step size is 1. The three arguments <start> <stop> <step> must all be nonnegative integers, and <stop> must not be smaller than <start>; other‐ wise you enter the danger zone of undocumented behavior that may change in future releases. foreach(loop_var IN [LISTS [<lists>]] [ITEMS [<items>]]) In this variant, <lists> is a whitespace or semicolon separated list of list-valued variables. The foreach command iterates over each item in each given list. The <items> following the ITEMS keyword are processed as in the first variant of the foreach command. The forms LISTS A and ITEMS ${A} are equivalent. The following example shows how the LISTS option is processed: set(A 0;1) set(B 2 3) set(C 4 5) set(D 6;7 8) set(E ) foreach(X IN LISTS A B C D E) message(STATUS X=${X}) endforeach() yields -- X=0 -- X=1 -- X=2 -- X=3 -- X=4 5 -- X=6 -- X=7 -- X=8 function Start recording a function for later invocation as a command. function(<name> [<arg1> ...]) <commands> endfunction() Defines a function named <name> that takes arguments named <arg1>, … The <commands> in the function definition are recorded; they are not exe‐ cuted until the function is invoked. Per legacy, the endfunction() command admits an optional <name> argument. If used, it must be a verbatim repeat of the argument of the opening function command. A function opens a new scope: see set(var PARENT_SCOPE) for details. See the cmake_policy() command documentation for the behavior of policies inside functions. See the macro() command documentation for differences between CMake functions and macros. Invocation The function invocation is case-insensitive. A function defined as function(foo) <commands> endfunction() can be invoked through any of foo() Foo() FOO() and so on. However, it is strongly recommended to stay with the case chosen in the function definition. Typically functions use all-lowercase names. Arguments When the function is invoked, the recorded <commands> are first modified by replacing formal parameters (${arg1}, …) with the arguments passed, and then invoked as normal commands. In addition to referencing the formal parameters you can reference the ARGC variable which will be set to the number of arguments passed into the function as well as ARGV0, ARGV1, ARGV2, … which will have the actual values of the arguments passed in. This facilitates creating functions with optional arguments. Furthermore, ARGV holds the list of all arguments given to the function and ARGN holds the list of arguments past the last expected argument. Referencing to ARGV# arguments beyond ARGC have undefined behavior. Checking that ARGC is greater than # is the only way to ensure that ARGV# was passed to the function as an extra argument. get_cmake_property Get a global property of the CMake instance. get_cmake_property(<var> <property>) Gets a global property from the CMake instance. The value of the <property> is stored in the variable <var>. If the property is not found, <var> will be set to NOTFOUND. See the cmake-properties(7) manual for available properties. See also the get_property() command GLOBAL option. In addition to global properties, this command (for historical reasons) also supports the VARIABLES and MACROS directory properties. It also sup‐ ports a special COMPONENTS global property that lists the components given to the install() command. get_directory_property Get a property of DIRECTORY scope. get_directory_property(<variable> [DIRECTORY <dir>] <prop-name>) Stores a property of directory scope in the named <variable>. The DIRECTORY argument specifies another directory from which to retrieve the prop‐ erty value instead of the current directory. The specified directory must have already been traversed by CMake. If the property is not defined for the nominated directory scope, an empty string is returned. In the case of INHERITED properties, if the prop‐ erty is not found for the nominated directory scope, the search will chain to a parent scope as described for the define_property() command. get_directory_property(<variable> [DIRECTORY <dir>] DEFINITION <var-name>) Get a variable definition from a directory. This form is useful to get a variable definition from another directory. See also the more general get_property() command. get_filename_component Get a specific component of a full filename. get_filename_component(<var> <FileName> <mode> [CACHE]) Sets <var> to a component of <FileName>, where <mode> is one of: DIRECTORY = Directory without file name NAME = File name without directory EXT = File name longest extension (.b.c from d/a.b.c) NAME_WE = File name without directory or longest extension LAST_EXT = File name last extension (.c from d/a.b.c) NAME_WLE = File name without directory or last extension PATH = Legacy alias for DIRECTORY (use for CMake <= 2.8.11) Paths are returned with forward slashes and have no trailing slashes. If the optional CACHE argument is specified, the result variable is added to the cache. get_filename_component(<var> <FileName> <mode> [BASE_DIR <dir>] [CACHE]) Sets <var> to the absolute path of <FileName>, where <mode> is one of: ABSOLUTE = Full path to file REALPATH = Full path to existing file with symlinks resolved If the provided <FileName> is a relative path, it is evaluated relative to the given base directory <dir>. If no base directory is provided, the default base directory will be CMAKE_CURRENT_SOURCE_DIR. Paths are returned with forward slashes and have no trailing slashes. If the optional CACHE argument is specified, the result variable is added to the cache. get_filename_component(<var> <FileName> PROGRAM [PROGRAM_ARGS <arg_var>] [CACHE]) The program in <FileName> will be found in the system search path or left as a full path. If PROGRAM_ARGS is present with PROGRAM, then any com‐ mand-line arguments present in the <FileName> string are split from the program name and stored in <arg_var>. This is used to separate a program name from its arguments in a command line string. get_property Get a property. get_property(<variable> <GLOBAL | DIRECTORY [<dir>] | TARGET <target> | SOURCE <source> | INSTALL <file> | TEST <test> | CACHE <entry> | VARIABLE > PROPERTY <name> [SET | DEFINED | BRIEF_DOCS | FULL_DOCS]) Gets one property from one object in a scope. The first argument specifies the variable in which to store the result. The second argument determines the scope from which to get the property. It must be one of the following: GLOBAL Scope is unique and does not accept a name. DIRECTORY Scope defaults to the current directory but another directory (already processed by CMake) may be named by the full or relative path <dir>. TARGET Scope must name one existing target. SOURCE Scope must name one source file. INSTALL Scope must name one installed file path. TEST Scope must name one existing test. CACHE Scope must name one cache entry. VARIABLE Scope is unique and does not accept a name. The required PROPERTY option is immediately followed by the name of the property to get. If the property is not set an empty value is returned, although some properties support inheriting from a parent scope if defined to behave that way (see define_property()). If the SET option is given the variable is set to a boolean value indicating whether the property has been set. If the DEFINED option is given the variable is set to a boolean value indicating whether the property has been defined such as with the define_property() command. If BRIEF_DOCS or FULL_DOCS is given then the variable is set to a string containing documentation for the requested property. If documentation is requested for a property that has not been defined NOTFOUND is returned. if Conditionally execute a group of commands. Synopsis if(<condition>) <commands> elseif(<condition>) # optional block, can be repeated <commands> else() # optional block <commands> endif() Evaluates the condition argument of the if clause according to the Condition syntax described below. If the result is true, then the commands in the if block are executed. Otherwise, optional elseif blocks are processed in the same way. Finally, if no condition is true, commands in the optional else block are executed. Per legacy, the else() and endif() commands admit an optional <condition> argument. If used, it must be a verbatim repeat of the argument of the opening if command. Condition Syntax The following syntax applies to the condition argument of the if, elseif and while() clauses. Compound conditions are evaluated in the following order of precedence: Innermost parentheses are evaluated first. Next come unary tests such as EXISTS, COMMAND, and DEFINED. Then binary tests such as EQUAL, LESS, LESS_EQUAL, GREATER, GREATER_EQUAL, STREQUAL, STRLESS, STRLESS_EQUAL, STR‐ GREATER, STRGREATER_EQUAL, VERSION_EQUAL, VERSION_LESS, VERSION_LESS_EQUAL, VERSION_GREATER, VERSION_GREATER_EQUAL, and MATCHES. Then the boolean operators in the order NOT, AND, and finally OR. Possible conditions are: if(<constant>) True if the constant is 1, ON, YES, TRUE, Y, or a non-zero number. False if the constant is 0, OFF, NO, FALSE, N, IGNORE, NOTFOUND, the empty string, or ends in the suffix -NOTFOUND. Named boolean constants are case-insensitive. If the argument is not one of these specific constants, it is treated as a variable or string and the following signature is used. if(<variable|string>) True if given a variable that is defined to a value that is not a false constant. False otherwise. (Note macro arguments are not vari‐ ables.) if(NOT <condition>) True if the condition is not true. if(<cond1> AND <cond2>) True if both conditions would be considered true individually. if(<cond1> OR <cond2>) True if either condition would be considered true individually. if(COMMAND command-name) True if the given name is a command, macro or function that can be invoked. if(POLICY policy-id) True if the given name is an existing policy (of the form CMP<NNNN>). if(TARGET target-name) True if the given name is an existing logical target name created by a call to the add_executable(), add_library(), or add_custom_target() command that has already been invoked (in any directory). if(TEST test-name) True if the given name is an existing test name created by the add_test() command. if(EXISTS path-to-file-or-directory) True if the named file or directory exists. Behavior is well-defined only for full paths. Resolves symbolic links, i.e. if the named file or directory is a symbolic link, returns true if the target of the symbolic link exists. if(file1 IS_NEWER_THAN file2) True if file1 is newer than file2 or if one of the two files doesn’t exist. Behavior is well-defined only for full paths. If the file time stamps are exactly the same, an IS_NEWER_THAN comparison returns true, so that any dependent build operations will occur in the event of a tie. This includes the case of passing the same file name for both file1 and file2. if(IS_DIRECTORY path-to-directory) True if the given name is a directory. Behavior is well-defined only for full paths. if(IS_SYMLINK file-name) True if the given name is a symbolic link. Behavior is well-defined only for full paths. if(IS_ABSOLUTE path) True if the given path is an absolute path. if(<variable|string> MATCHES regex) True if the given string or variable’s value matches the given regular condition. See Regex Specification for regex format. () groups are captured in CMAKE_MATCH_<n> variables. if(<variable|string> LESS <variable|string>) True if the given string or variable’s value is a valid number and less than that on the right. if(<variable|string> GREATER <variable|string>) True if the given string or variable’s value is a valid number and greater than that on the right. if(<variable|string> EQUAL <variable|string>) True if the given string or variable’s value is a valid number and equal to that on the right. if(<variable|string> LESS_EQUAL <variable|string>) True if the given string or variable’s value is a valid number and less than or equal to that on the right. if(<variable|string> GREATER_EQUAL <variable|string>) True if the given string or variable’s value is a valid number and greater than or equal to that on the right. if(<variable|string> STRLESS <variable|string>) True if the given string or variable’s value is lexicographically less than the string or variable on the right. if(<variable|string> STRGREATER <variable|string>) True if the given string or variable’s value is lexicographically greater than the string or variable on the right. if(<variable|string> STREQUAL <variable|string>) True if the given string or variable’s value is lexicographically equal to the string or variable on the right. if(<variable|string> STRLESS_EQUAL <variable|string>) True if the given string or variable’s value is lexicographically less than or equal to the string or variable on the right. if(<variable|string> STRGREATER_EQUAL <variable|string>) True if the given string or variable’s value is lexicographically greater than or equal to the string or variable on the right. if(<variable|string> VERSION_LESS <variable|string>) Component-wise integer version number comparison (version format is major[.minor[.patch[.tweak]]], omitted components are treated as zero). Any non-integer version component or non-integer trailing part of a version component effectively truncates the string at that point. if(<variable|string> VERSION_GREATER <variable|string>) Component-wise integer version number comparison (version format is major[.minor[.patch[.tweak]]], omitted components are treated as zero). Any non-integer version component or non-integer trailing part of a version component effectively truncates the string at that point. if(<variable|string> VERSION_EQUAL <variable|string>) Component-wise integer version number comparison (version format is major[.minor[.patch[.tweak]]], omitted components are treated as zero). Any non-integer version component or non-integer trailing part of a version component effectively truncates the string at that point. if(<variable|string> VERSION_LESS_EQUAL <variable|string>) Component-wise integer version number comparison (version format is major[.minor[.patch[.tweak]]], omitted components are treated as zero). Any non-integer version component or non-integer trailing part of a version component effectively truncates the string at that point. if(<variable|string> VERSION_GREATER_EQUAL <variable|string>) Component-wise integer version number comparison (version format is major[.minor[.patch[.tweak]]], omitted components are treated as zero). Any non-integer version component or non-integer trailing part of a version component effectively truncates the string at that point. if(<variable|string> IN_LIST <variable>) True if the given element is contained in the named list variable. if(DEFINED <name>|CACHE{<name>}|ENV{<name>}) True if a variable, cache variable or environment variable with given <name> is defined. The value of the variable does not matter. Note that macro arguments are not variables. if((condition) AND (condition OR (condition))) The conditions inside the parenthesis are evaluated first and then the remaining condition is evaluated as in the previous examples. Where there are nested parenthesis the innermost are evaluated as part of evaluating the condition that contains them. Variable Expansion The if command was written very early in CMake’s history, predating the ${} variable evaluation syntax, and for convenience evaluates variables named by its arguments as shown in the above signatures. Note that normal variable evaluation with ${} applies before the if command even re‐ ceives the arguments. Therefore code like set(var1 OFF) set(var2 var1) if(${var2}) appears to the if command as if(var1) and is evaluated according to the if(<variable>) case documented above. The result is OFF which is false. However, if we remove the ${} from the example then the command sees if(var2) which is true because var2 is defined to var1 which is not a false constant. Automatic evaluation applies in the other cases whenever the above-documented condition syntax accepts <variable|string>: • The left hand argument to MATCHES is first checked to see if it is a defined variable, if so the variable’s value is used, otherwise the origi‐ nal value is used. • If the left hand argument to MATCHES is missing it returns false without error • Both left and right hand arguments to LESS, GREATER, EQUAL, LESS_EQUAL, and GREATER_EQUAL, are independently tested to see if they are defined variables, if so their defined values are used otherwise the original value is used. • Both left and right hand arguments to STRLESS, STRGREATER, STREQUAL, STRLESS_EQUAL, and STRGREATER_EQUAL are independently tested to see if they are defined variables, if so their defined values are used otherwise the original value is used. • Both left and right hand arguments to VERSION_LESS, VERSION_GREATER, VERSION_EQUAL, VERSION_LESS_EQUAL, and VERSION_GREATER_EQUAL are indepen‐ dently tested to see if they are defined variables, if so their defined values are used otherwise the original value is used. • The right hand argument to NOT is tested to see if it is a boolean constant, if so the value is used, otherwise it is assumed to be a variable and it is dereferenced. • The left and right hand arguments to AND and OR are independently tested to see if they are boolean constants, if so they are used as such, oth‐ erwise they are assumed to be variables and are dereferenced. To prevent ambiguity, potential variable or keyword names can be specified in a Quoted Argument or a Bracket Argument. A quoted or bracketed variable or keyword will be interpreted as a string and not dereferenced or interpreted. See policy CMP0054. There is no automatic evaluation for environment or cache Variable References. Their values must be referenced as $ENV{<name>} or $CACHE{<name>} wherever the above-documented condition syntax accepts <variable|string>. include Load and run CMake code from a file or module. include(<file|module> [OPTIONAL] [RESULT_VARIABLE <var>] [NO_POLICY_SCOPE]) Loads and runs CMake code from the file given. Variable reads and writes access the scope of the caller (dynamic scoping). If OPTIONAL is present, then no error is raised if the file does not exist. If RESULT_VARIABLE is given the variable <var> will be set to the full filename which has been included or NOTFOUND if it failed. If a module is specified instead of a file, the file with name <modulename>.cmake is searched first in CMAKE_MODULE_PATH, then in the CMake module directory. There is one exception to this: if the file which calls include() is located itself in the CMake builtin module directory, then first the CMake builtin module directory is searched and CMAKE_MODULE_PATH afterwards. See also policy CMP0017. See the cmake_policy() command documentation for discussion of the NO_POLICY_SCOPE option. include_guard Provides an include guard for the file currently being processed by CMake. include_guard([DIRECTORY|GLOBAL]) Sets up an include guard for the current CMake file (see the CMAKE_CURRENT_LIST_FILE variable documentation). CMake will end its processing of the current file at the location of the include_guard() command if the current file has already been processed for the applicable scope (see below). This provides functionality similar to the include guards commonly used in source headers or to the #pragma once directive. If the current file has been processed previously for the applicable scope, the effect is as though return() had been called. Do not call this command from inside a function being defined within the current file. An optional argument specifying the scope of the guard may be provided. Possible values for the option are: DIRECTORY The include guard applies within the current directory and below. The file will only be included once within this directory scope, but may be included again by other files outside of this directory (i.e. a parent directory or another directory not pulled in by add_subdirec‐ tory() or include() from the current file or its children). GLOBAL The include guard applies globally to the whole build. The current file will only be included once regardless of the scope. If no arguments given, include_guard has the same scope as a variable, meaning that the include guard effect is isolated by the most recent func‐ tion scope or current directory if no inner function scopes exist. In this case the command behavior is the same as: if(__CURRENT_FILE_VAR__) return() endif() set(__CURRENT_FILE_VAR__ TRUE) list List operations. Synopsis Reading list(LENGTH <list> <out-var>) list(GET <list> <element index> [<index> ...] <out-var>) list(JOIN <list> <glue> <out-var>) list(SUBLIST <list> <begin> <length> <out-var>) Search list(FIND <list> <value> <out-var>) Modification list(APPEND <list> [<element>...]) list(FILTER <list> {INCLUDE | EXCLUDE} REGEX <regex>) list(INSERT <list> <index> [<element>...]) list(POP_BACK <list> [<out-var>...]) list(POP_FRONT <list> [<out-var>...]) list(PREPEND <list> [<element>...]) list(REMOVE_ITEM <list> <value>...) list(REMOVE_AT <list> <index>...) list(REMOVE_DUPLICATES <list>) list(TRANSFORM <list> <ACTION> [...]) Ordering list(REVERSE <list>) list(SORT <list> [...]) Introduction The list subcommands APPEND, INSERT, FILTER, PREPEND, POP_BACK, POP_FRONT, REMOVE_AT, REMOVE_ITEM, REMOVE_DUPLICATES, REVERSE and SORT may create new values for the list within the current CMake variable scope. Similar to the set() command, the LIST command creates new variable values in the current scope, even if the list itself is actually defined in a parent scope. To propagate the results of these operations upwards, use set() with PARENT_SCOPE, set() with CACHE INTERNAL, or some other means of value propagation. NOTE: A list in cmake is a ; separated group of strings. To create a list the set command can be used. For example, set(var a b c d e) creates a list with a;b;c;d;e, and set(var a b c d e) creates a string or a list with one item in it. (Note macro arguments are not variables, and therefore cannot be used in LIST commands.) NOTE: When specifying index values, if <element index> is 0 or greater, it is indexed from the beginning of the list, with 0 representing the first list element. If <element index> is -1 or lesser, it is indexed from the end of the list, with -1 representing the last list element. Be careful when counting with negative indices: they do not start from 0. -0 is equivalent to 0, the first list element. Reading list(LENGTH <list> <output variable>) Returns the list’s length. list(GET <list> <element index> [<element index> ...] <output variable>) Returns the list of elements specified by indices from the list. list(JOIN <list> <glue> <output variable>) Returns a string joining all list’s elements using the glue string. To join multiple strings, which are not part of a list, use JOIN operator from string() command. list(SUBLIST <list> <begin> <length> <output variable>) Returns a sublist of the given list. If <length> is 0, an empty list will be returned. If <length> is -1 or the list is smaller than <be‐ gin>+<length> then the remaining elements of the list starting at <begin> will be returned. Search list(FIND <list> <value> <output variable>) Returns the index of the element specified in the list or -1 if it wasn’t found. Modification list(APPEND <list> [<element> ...]) Appends elements to the list. list(FILTER <list> <INCLUDE|EXCLUDE> REGEX <regular_expression>) Includes or removes items from the list that match the mode’s pattern. In REGEX mode, items will be matched against the given regular expression. For more information on regular expressions see also the string() command. list(INSERT <list> <element_index> <element> [<element> ...]) Inserts elements to the list to the specified location. list(POP_BACK <list> [<out-var>...]) If no variable name is given, removes exactly one element. Otherwise, assign the last element’s value to the given variable and removes it, up to the last variable name given. list(POP_FRONT <list> [<out-var>...]) If no variable name is given, removes exactly one element. Otherwise, assign the first element’s value to the given variable and removes it, up to the last variable name given. list(PREPEND <list> [<element> ...]) Insert elements to the 0th position in the list. list(REMOVE_ITEM <list> <value> [<value> ...]) Removes all instances of the given items from the list. list(REMOVE_AT <list> <index> [<index> ...]) Removes items at given indices from the list. list(REMOVE_DUPLICATES <list>) Removes duplicated items in the list. The relative order of items is preserved, but if duplicates are encountered, only the first instance is pre‐ served. list(TRANSFORM <list> <ACTION> [<SELECTOR>] [OUTPUT_VARIABLE <output variable>]) Transforms the list by applying an action to all or, by specifying a <SELECTOR>, to the selected elements of the list, storing the result in-place or in the specified output variable. NOTE: The TRANSFORM sub-command does not change the number of elements in the list. If a <SELECTOR> is specified, only some elements will be changed, the other ones will remain the same as before the transformation. <ACTION> specifies the action to apply to the elements of the list. The actions have exactly the same semantics as sub-commands of the string() command. <ACTION> must be one of the following: APPEND, PREPEND: Append, prepend specified value to each element of the list. list(TRANSFORM <list> <APPEND|PREPEND> <value> ...) TOUPPER, TOLOWER: Convert each element of the list to upper, lower characters. list(TRANSFORM <list> <TOLOWER|TOUPPER> ...) STRIP: Remove leading and trailing spaces from each element of the list. list(TRANSFORM <list> STRIP ...) GENEX_STRIP: Strip any generator expressions from each element of the list. list(TRANSFORM <list> GENEX_STRIP ...) REPLACE: Match the regular expression as many times as possible and substitute the replacement expression for the match for each element of the list (Same semantic as REGEX REPLACE from string() command). list(TRANSFORM <list> REPLACE <regular_expression> <replace_expression> ...) <SELECTOR> determines which elements of the list will be transformed. Only one type of selector can be specified at a time. When given, <SELEC‐ TOR> must be one of the following: AT: Specify a list of indexes. list(TRANSFORM <list> <ACTION> AT <index> [<index> ...] ...) FOR: Specify a range with, optionally, an increment used to iterate over the range. list(TRANSFORM <list> <ACTION> FOR <start> <stop> [<step>] ...) REGEX: Specify a regular expression. Only elements matching the regular expression will be transformed. list(TRANSFORM <list> <ACTION> REGEX <regular_expression> ...) Ordering list(REVERSE <list>) Reverses the contents of the list in-place. list(SORT <list> [COMPARE <compare>] [CASE <case>] [ORDER <order>]) Sorts the list in-place alphabetically. Use the COMPARE keyword to select the comparison method for sorting. The <compare> option should be one of: • STRING: Sorts a list of strings alphabetically. This is the default behavior if the COMPARE option is not given. • FILE_BASENAME: Sorts a list of pathnames of files by their basenames. Use the CASE keyword to select a case sensitive or case insensitive sort mode. The <case> option should be one of: • SENSITIVE: List items are sorted in a case-sensitive manner. This is the default behavior if the CASE option is not given. • INSENSITIVE: List items are sorted case insensitively. The order of items which differ only by upper/lowercase is not specified. To control the sort order, the ORDER keyword can be given. The <order> option should be one of: • ASCENDING: Sorts the list in ascending order. This is the default behavior when the ORDER option is not given. • DESCENDING: Sorts the list in descending order. macro Start recording a macro for later invocation as a command macro(<name> [<arg1> ...]) <commands> endmacro() Defines a macro named <name> that takes arguments named <arg1>, … Commands listed after macro, but before the matching endmacro(), are not exe‐ cuted until the macro is invoked. Per legacy, the endmacro() command admits an optional <name> argument. If used, it must be a verbatim repeat of the argument of the opening macro command. See the cmake_policy() command documentation for the behavior of policies inside macros. See the Macro vs Function section below for differences between CMake macros and functions. Invocation The macro invocation is case-insensitive. A macro defined as macro(foo) <commands> endmacro() can be invoked through any of foo() Foo() FOO() and so on. However, it is strongly recommended to stay with the case chosen in the macro definition. Typically macros use all-lowercase names. Arguments When a macro is invoked, the commands recorded in the macro are first modified by replacing formal parameters (${arg1}, …) with the arguments passed, and then invoked as normal commands. In addition to referencing the formal parameters you can reference the values ${ARGC} which will be set to the number of arguments passed into the function as well as ${ARGV0}, ${ARGV1}, ${ARGV2}, … which will have the actual values of the arguments passed in. This facilitates creating macros with optional arguments. Furthermore, ${ARGV} holds the list of all arguments given to the macro and ${ARGN} holds the list of arguments past the last expected argument. Referencing to ${ARGV#} arguments beyond ${ARGC} have undefined behavior. Checking that ${ARGC} is greater than # is the only way to ensure that ${ARGV#} was passed to the function as an extra argument. Macro vs Function The macro command is very similar to the function() command. Nonetheless, there are a few important differences. In a function, ARGN, ARGC, ARGV and ARGV0, ARGV1, … are true variables in the usual CMake sense. In a macro, they are not, they are string re‐ placements much like the C preprocessor would do with a macro. This has a number of consequences, as explained in the Argument Caveats section below. Another difference between macros and functions is the control flow. A function is executed by transferring control from the calling statement to the function body. A macro is executed as if the macro body were pasted in place of the calling statement. This has the consequence that a return() in a macro body does not just terminate execution of the macro; rather, control is returned from the scope of the macro call. To avoid confusion, it is recommended to avoid return() in macros altogether. Argument Caveats Since ARGN, ARGC, ARGV, ARGV0 etc. are not variables, you will NOT be able to use commands like if(ARGV1) # ARGV1 is not a variable if(DEFINED ARGV2) # ARGV2 is not a variable if(ARGC GREATER 2) # ARGC is not a variable foreach(loop_var IN LISTS ARGN) # ARGN is not a variable In the first case, you can use if(${ARGV1}). In the second and third case, the proper way to check if an optional variable was passed to the macro is to use if(${ARGC} GREATER 2). In the last case, you can use foreach(loop_var ${ARGN}) but this will skip empty arguments. If you need to include them, you can use set(list_var ${ARGN}) foreach(loop_var IN LISTS list_var) Note that if you have a variable with the same name in the scope from which the macro is called, using unreferenced names will use the existing variable instead of the arguments. For example: macro(bar) foreach(arg IN LISTS ARGN) <commands> endforeach() endmacro() function(foo) bar(x y z) endfunction() foo(a b c) Will loop over a;b;c and not over x;y;z as one might have expected. If you want true CMake variables and/or better CMake scope control you should look at the function command. mark_as_advanced Mark cmake cached variables as advanced. mark_as_advanced([CLEAR|FORCE] <var1> ...) Sets the advanced/non-advanced state of the named cached variables. An advanced variable will not be displayed in any of the cmake GUIs unless the show advanced option is on. In script mode, the advanced/non-ad‐ vanced state has no effect. If the keyword CLEAR is given then advanced variables are changed back to unadvanced. If the keyword FORCE is given then the variables are made advanced. If neither FORCE nor CLEAR is specified, new values will be marked as advanced, but if a variable already has an advanced/non-advanced state, it will not be changed. math Evaluate a mathematical expression. math(EXPR <variable> <expression> [OUTPUT_FORMAT <format>]) Evaluates a mathematical <expression> and sets <variable> to the resulting value. The result of the expression must be representable as a 64-bit signed integer. The mathematical expression must be given as a string (i.e. enclosed in double quotation marks). An example is 5 * (10 + 13). Supported opera‐ tors are +, -, *, /, %, |, &, ^, ~, <<, >>, and (...); they have the same meaning as in C code. Hexadecimal numbers are recognized when prefixed with 0x, as in C code. The result is formatted according to the option OUTPUT_FORMAT, where <format> is one of HEXADECIMAL Hexadecimal notation as in C code, i. e. starting with “0x”. DECIMAL Decimal notation. Which is also used if no OUTPUT_FORMAT option is specified. For example math(EXPR value 100 * 0xA OUTPUT_FORMAT DECIMAL) # value is set to 1000 math(EXPR value 100 * 0xA OUTPUT_FORMAT HEXADECIMAL) # value is set to 0x3e8 message Display a message to the user. message([<mode>] message to display ...) The optional <mode> keyword determines the type of message: FATAL_ERROR CMake Error, stop processing and generation. SEND_ERROR CMake Error, continue processing, but skip generation. WARNING CMake Warning, continue processing. AUTHOR_WARNING CMake Warning (dev), continue processing. DEPRECATION CMake Deprecation Error or Warning if variable CMAKE_ERROR_DEPRECATED or CMAKE_WARN_DEPRECATED is enabled, respectively, else no message. (none) or NOTICE Important message printed to stderr to attract user’s attention. STATUS The main interesting messages that project users might be interested in. Ideally these should be concise, no more than a single line, but still informative. VERBOSE Detailed informational messages intended for project users. These messages should provide additional details that won’t be of interest in most cases, but which may be useful to those building the project when they want deeper insight into what’s happening. DEBUG Detailed informational messages intended for developers working on the project itself as opposed to users who just want to build it. These messages will not typically be of interest to other users building the project and will often be closely related to internal implementation details. TRACE Fine-grained messages with very low-level implementation details. Messages using this log level would normally only be temporary and would expect to be removed before releasing the project, packaging up the files, etc. The CMake command-line tool displays STATUS to TRACE messages on stdout with the message preceded by two hyphens and a space. All other message types are sent to stderr and are not prefixed with hyphens. The CMake GUI displays all messages in its log area. The curses interface shows STA‐ TUS to TRACE messages one at a time on a status line and other messages in an interactive pop-up box. The --log-level command-line option to each of these tools can be used to control which messages will be shown. Messages of log levels NOTICE and below will also have each line preceded by the content of the CMAKE_MESSAGE_INDENT variable (converted to a sin‐ gle string by concatenating its list items). For STATUS to TRACE messages, this indenting content will be inserted after the hyphens. CMake Warning and Error message text displays using a simple markup language. Non-indented text is formatted in line-wrapped paragraphs delimited by newlines. Indented text is considered pre-formatted. option Provide an option that the user can optionally select. option(<variable> <help_text> [value]) Provides an option for the user to select as ON or OFF. If no initial <value> is provided, OFF is used. If <variable> is already set as a normal variable then the command does nothing (see policy CMP0077). If you have options that depend on the values of other options, see the module help for CMakeDependentOption. return Return from a file, directory or function. return() Returns from a file, directory or function. When this command is encountered in an included file (via include() or find_package()), it causes processing of the current file to stop and control is returned to the including file. If it is encountered in a file which is not included by an‐ other file, e.g. a CMakeLists.txt, control is returned to the parent directory if there is one. If return is called in a function, control is returned to the caller of the function. Note that a macro, unlike a function, is expanded in place and therefore cannot handle return(). separate_arguments Parse command-line arguments into a semicolon-separated list. separate_arguments(<variable> <mode> <args>) Parses a space-separated string <args> into a list of items, and stores this list in semicolon-separated standard form in <variable>. This function is intended for parsing command-line arguments. The entire command line must be passed as one string in the argument <args>. The exact parsing rules depend on the operating system. They are specified by the <mode> argument which must be one of the following keywords: UNIX_COMMAND Arguments are separated by by unquoted whitespace. Both single-quote and double-quote pairs are respected. A backslash escapes the next literal character
