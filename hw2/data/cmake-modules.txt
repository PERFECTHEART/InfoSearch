The description of a component. CPACK_COMPONENT_<compName>_GROUP The group of a component. CPACK_COMPONENT_<compName>_DEPENDS The dependencies (list of components) on which this component depends. CPACK_COMPONENT_<compName>_HIDDEN True if this component is hidden from the user. CPACK_COMPONENT_<compName>_REQUIRED True if this component is required. CPACK_COMPONENT_<compName>_DISABLED True if this component is not selected to be installed by default. cpack_add_component Describes a CPack installation component named by the COMPONENT argument to a CMake INSTALL command. cpack_add_component(compname [DISPLAY_NAME name] [HIDDEN | REQUIRED | DISABLED ] [GROUP group] [DEPENDS comp1 comp2 ... ] [INSTALL_TYPES type1 type2 ... ] [DOWNLOADED] [ARCHIVE_FILE filename] [PLIST filename]) The cmake_add_component command describes an installation component, which the user can opt to install or remove as part of the graphical instal‐ lation process. compname is the name of the component, as provided to the COMPONENT argument of one or more CMake INSTALL commands. DISPLAY_NAME is the displayed name of the component, used in graphical installers to display the component name. This value can be any string. Descriptions can span multiple lines using n as the line separator. Typically, these descriptions should be no more than a few lines long. HIDDEN indicates that this component will be hidden in the graphical installer, so that the user cannot directly change whether it is installed or not. REQUIRED indicates that this component is required, and therefore will always be installed. It will be visible in the graphical installer, but it cannot be unselected. (Typically, required components are shown greyed out). DISABLED indicates that this component should be disabled (unselected) by default. The user is free to select this component for installation, unless it is also HIDDEN. DEPENDS lists the components on which this component depends. If this component is selected, then each of the components listed must also be se‐ lected. The dependency information is encoded within the installer itself, so that users cannot install inconsistent sets of components. GROUP names the component group of which this component is a part. If not provided, the component will be a standalone component, not part of any component group. Component groups are described with the cpack_add_component_group command, detailed below. INSTALL_TYPES lists the installation types of which this component is a part. When one of these installations types is selected, this component will automatically be selected. Installation types are described with the cpack_add_install_type command, detailed below. DOWNLOADED indicates that this component should be downloaded on-the-fly by the installer, rather than packaged in with the installer itself. For more information, see the cpack_configure_downloads command. ARCHIVE_FILE provides a name for the archive file created by CPack to be used for downloaded components. If not supplied, CPack will create a file with some name based on CPACK_PACKAGE_FILE_NAME and the name of the component. See cpack_configure_downloads for more information. PLIST gives a filename that is passed to pkgbuild with the --component-plist argument when using the productbuild generator. cpack_add_component_group Describes a group of related CPack installation components. cpack_add_component_group(groupname [DISPLAY_NAME name] [PARENT_GROUP parent] [EXPANDED] [BOLD_TITLE]) The cpack_add_component_group describes a group of installation components, which will be placed together within the listing of options. Typi‐ cally, component groups allow the user to select/deselect all of the components within a single group via a single group-level option. Use compo‐ nent groups to reduce the complexity of installers with many options. groupname is an arbitrary name used to identify the group in the GROUP ar‐ gument of the cpack_add_component command, which is used to place a component in a group. The name of the group must not conflict with the name of any component. DISPLAY_NAME is the displayed name of the component group, used in graphical installers to display the component group name. This value can be any string. ponents within that group. Descriptions can span multiple lines using n as the line separator. Typically, these descriptions should be no more than a few lines long. PARENT_GROUP, if supplied, names the parent group of this group. Parent groups are used to establish a hierarchy of groups, providing an arbi‐ trary hierarchy of groups. EXPANDED indicates that, by default, the group should show up as “expanded”, so that the user immediately sees all of the components within the group. Otherwise, the group will initially show up as a single entry. BOLD_TITLE indicates that the group title should appear in bold, to call the user’s attention to the group. cpack_add_install_type Add a new installation type containing a set of predefined component selections to the graphical installer. cpack_add_install_type(typename [DISPLAY_NAME name]) The cpack_add_install_type command identifies a set of preselected components that represents a common use case for an application. For example, a “Developer” install type might include an application along with its header and library files, while an “End user” install type might just in‐ clude the application’s executable. Each component identifies itself with one or more install types via the INSTALL_TYPES argument to cpack_add_component. DISPLAY_NAME is the displayed name of the install type, which will typically show up in a drop-down box within a graphical installer. This value can be any string. cpack_configure_downloads Configure CPack to download selected components on-the-fly as part of the installation process. cpack_configure_downloads(site [UPLOAD_DIRECTORY dirname] [ALL] [ADD_REMOVE|NO_ADD_REMOVE]) The cpack_configure_downloads command configures installation-time downloads of selected components. For each downloadable component, CPack will create an archive containing the contents of that component, which should be uploaded to the given site. When the user selects that component for installation, the installer will download and extract the component in place. This feature is useful for creating small installers that only download the requested components, saving bandwidth. Additionally, the installers are small enough that they will be installed as part of the normal installation process, and the “Change” button in Windows Add/Remove Programs control panel will allow one to add or remove parts of the ap‐ plication after the original installation. On Windows, the downloaded-components functionality requires the ZipDLL plug-in for NSIS, available at: http://nsis.sourceforge.net/ZipDLL_plug-in On macOS, installers that download components on-the-fly can only be built and installed on system using macOS 10.5 or later. The site argument is a URL where the archives for downloadable components will reside, e.g., https://cmake.org/files/2.6.1/installer/ All of the archives produced by CPack should be uploaded to that location. UPLOAD_DIRECTORY is the local directory where CPack will create the various archives for each of the components. The contents of this directory should be uploaded to a location accessible by the URL given in the site argument. If omitted, CPack will use the directory CPackUploads inside the CMake binary directory to store the generated archives. The ALL flag indicates that all components be downloaded. Otherwise, only those components explicitly marked as DOWNLOADED or that have a speci‐ fied ARCHIVE_FILE will be downloaded. Additionally, the ALL option implies ADD_REMOVE (unless NO_ADD_REMOVE is specified). ADD_REMOVE indicates that CPack should install a copy of the installer that can be called from Windows’ Add/Remove Programs dialog (via the “Mod‐ ify” button) to change the set of installed components. NO_ADD_REMOVE turns off this behavior. This option is ignored on Mac OS X. CPackIFW The documentation for the CPack IFW generator has moved here: CPack IFW Generator This module looks for the location of the command line utilities supplied with the Qt Installer Framework (QtIFW). The module also defines several commands to control the behavior of the CPack IFW generator. Commands The module defines the following commands: cpack_ifw_configure_component Sets the arguments specific to the CPack IFW generator. cpack_ifw_configure_component(<compname> [COMMON] [ESSENTIAL] [VIRTUAL] [FORCED_INSTALLATION] [REQUIRES_ADMIN_RIGHTS] [NAME <name>] [DISPLAY_NAME <display_name>] # Note: Internationalization supported [UPDATE_TEXT <update_text>] [VERSION <version>] [RELEASE_DATE <release_date>] [SCRIPT <script>] [PRIORITY|SORTING_PRIORITY <sorting_priority>] # Note: PRIORITY is deprecated [DEPENDS|DEPENDENCIES <com_id> ...] [AUTO_DEPEND_ON <comp_id> ...] [LICENSES <display_name> <file_path> ...] [DEFAULT <value>] [USER_INTERFACES <file_path> <file_path> ...] [TRANSLATIONS <file_path> <file_path> ...] [REPLACES <comp_id> ...] [CHECKABLE <value>]) This command should be called after cpack_add_component() command. COMMON if set, then the component will be packaged and installed as part of a group to which it belongs. ESSENTIAL if set, then the package manager stays disabled until that component is updated. VIRTUAL if set, then the component will be hidden from the installer. It is a equivalent of the HIDDEN option from the cpack_add_compo‐ nent() command. FORCED_INSTALLATION if set, then the component must always be installed. It is a equivalent of the REQUARED option from the cpack_add_component() com‐ mand. REQUIRES_ADMIN_RIGHTS set it if the component needs to be installed with elevated permissions. NAME is used to create domain-like identification for this component. By default used origin component name. DISPLAY_NAME set to rewrite original name configured by cpack_add_component() command. set to rewrite original description configured by cpack_add_component() command. UPDATE_TEXT will be added to the component description if this is an update to the component. VERSION is version of component. By default used CPACK_PACKAGE_VERSION. RELEASE_DATE keep empty to auto generate. SCRIPT is a relative or absolute path to operations script for this component. PRIORITY | SORTING_PRIORITY is priority of the component in the tree. The PRIORITY option is deprecated and will be removed in a future version of CMake. Please use SORTING_PRIORITY option instead. DEPENDS | DEPENDENCIES list of dependency component or component group identifiers in QtIFW style. AUTO_DEPEND_ON list of identifiers of component or component group in QtIFW style that this component has an automatic dependency on. LICENSES pair of <display_name> and <file_path> of license text for this component. You can specify more then one license. DEFAULT Possible values are: TRUE, FALSE, and SCRIPT. Set to FALSE to disable the component in the installer or to SCRIPT to resolved dur‐ ing runtime (don’t forget add the file of the script as a value of the SCRIPT option). USER_INTERFACES is a list of <file_path> (‘.ui’ files) representing pages to load. TRANSLATIONS is a list of <file_path> (‘.qm’ files) representing translations to load. REPLACES list of identifiers of component or component group to replace. CHECKABLE Possible values are: TRUE, FALSE. Set to FALSE if you want to hide the checkbox for an item. This is useful when only a few sub‐ components should be selected instead of all. cpack_ifw_configure_component_group Sets the arguments specific to the CPack IFW generator. cpack_ifw_configure_component_group(<groupname> [VIRTUAL] [FORCED_INSTALLATION] [REQUIRES_ADMIN_RIGHTS] [NAME <name>] [DISPLAY_NAME <display_name>] # Note: Internationalization supported [UPDATE_TEXT <update_text>] [VERSION <version>] [RELEASE_DATE <release_date>] [SCRIPT <script>] [PRIORITY|SORTING_PRIORITY <sorting_priority>] # Note: PRIORITY is deprecated [DEPENDS|DEPENDENCIES <com_id> ...] [AUTO_DEPEND_ON <comp_id> ...] [LICENSES <display_name> <file_path> ...] [DEFAULT <value>] [USER_INTERFACES <file_path> <file_path> ...] [TRANSLATIONS <file_path> <file_path> ...] [REPLACES <comp_id> ...] [CHECKABLE <value>]) This command should be called after cpack_add_component_group() command. VIRTUAL if set, then the group will be hidden from the installer. Note that setting this on a root component does not work. FORCED_INSTALLATION if set, then the group must always be installed. REQUIRES_ADMIN_RIGHTS set it if the component group needs to be installed with elevated permissions. NAME is used to create domain-like identification for this component group. By default used origin component group name. DISPLAY_NAME set to rewrite original name configured by cpack_add_component_group() command. set to rewrite original description configured by cpack_add_component_group() command. UPDATE_TEXT will be added to the component group description if this is an update to the component group. VERSION is version of component group. By default used CPACK_PACKAGE_VERSION. RELEASE_DATE keep empty to auto generate. SCRIPT is a relative or absolute path to operations script for this component group. PRIORITY | SORTING_PRIORITY is priority of the component group in the tree. The PRIORITY option is deprecated and will be removed in a future version of CMake. Please use SORTING_PRIORITY option instead. DEPENDS | DEPENDENCIES list of dependency component or component group identifiers in QtIFW style. AUTO_DEPEND_ON list of identifiers of component or component group in QtIFW style that this component group has an automatic dependency on. LICENSES pair of <display_name> and <file_path> of license text for this component group. You can specify more then one license. DEFAULT Possible values are: TRUE, FALSE, and SCRIPT. Set to TRUE to preselect the group in the installer (this takes effect only on groups that have no visible child components) or to SCRIPT to resolved during runtime (don’t forget add the file of the script as a value of the SCRIPT option). USER_INTERFACES is a list of <file_path> (‘.ui’ files) representing pages to load. TRANSLATIONS is a list of <file_path> (‘.qm’ files) representing translations to load. REPLACES list of identifiers of component or component group to replace. CHECKABLE Possible values are: TRUE, FALSE. Set to FALSE if you want to hide the checkbox for an item. This is useful when only a few sub‐ components should be selected instead of all. cpack_ifw_add_repository Add QtIFW specific remote repository to binary installer. cpack_ifw_add_repository(<reponame> [DISABLED] URL <url> [USERNAME <username>] [PASSWORD <password>] [DISPLAY_NAME <display_name>]) This command will also add the <reponame> repository to a variable CPACK_IFW_REPOSITORIES_ALL. DISABLED if set, then the repository will be disabled by default. URL is points to a list of available components. USERNAME is used as user on a protected repository. PASSWORD is password to use on a protected repository. DISPLAY_NAME is string to display instead of the URL. cpack_ifw_update_repository Update QtIFW specific repository from remote repository. cpack_ifw_update_repository(<reponame> [[ADD|REMOVE] URL <url>]| [REPLACE OLD_URL <old_url> NEW_URL <new_url>]] [USERNAME <username>] [PASSWORD <password>] [DISPLAY_NAME <display_name>]) This command will also add the <reponame> repository to a variable CPACK_IFW_REPOSITORIES_ALL. URL is points to a list of available components. OLD_URL is points to a list that will replaced. NEW_URL is points to a list that will replace to. USERNAME is used as user on a protected repository. PASSWORD is password to use on a protected repository. DISPLAY_NAME is string to display instead of the URL. cpack_ifw_add_package_resources Add additional resources in the installer binary. cpack_ifw_add_package_resources(<file_path> <file_path> ...) This command will also add the specified files to a variable CPACK_IFW_PACKAGE_RESOURCES. CPackIFWConfigureFile The module defines configure_file() similar command to configure file templates prepared in QtIFW/SDK/Creator style. Commands The module defines the following commands: cpack_ifw_configure_file Copy a file to another location and modify its contents. cpack_ifw_configure_file(<input> <output>) Copies an <input> file to an <output> file and substitutes variable values referenced as %{VAR} or %VAR% in the input file content. Each variable reference will be replaced with the current value of the variable, or the empty string if the variable is not defined. CPack Build binary and source package installers. Introduction The CPack module generates a file CPackConfig.cmake intended for use in a subsequent run of the cpack program where it steers the generation of installers or/and source packages. Inclusion of the CPack module adds two new build targets, package and package_source, which build the binary and source installers respectively. The generated binary installers contain everything installed via CMake’s install() command (and the deprecated commands install_files(), in‐ stall_programs(), and install_targets()). For certain kinds of binary installers (including the graphical installers on macOS and Windows), CPack generates installers that allow users to select individual application components to install. See CPackComponent module for further details. CPack Generators The CPACK_GENERATOR variable has different meanings in different contexts. In a CMakeLists.txt file, CPACK_GENERATOR is a list of generators: and when cpack is run with no other arguments, it will iterate over that list and produce one package for each generator. In a CPACK_PROJECT_CONFIG_FILE, CPACK_GENERATOR is a string naming a single generator. If you need per-cpack-generator logic to control other cpack settings, then you need a CPACK_PROJECT_CONFIG_FILE. The CMake source tree itself contains a CPACK_PROJECT_CONFIG_FILE. See the top level file CMakeCPackOptions.cmake.in for an example. If set, the CPACK_PROJECT_CONFIG_FILE is included automatically on a per-generator basis. It only need contain overrides. Here’s how it works: • cpack runs • it includes CPackConfig.cmake • it iterates over the generators given by the -G command line option, or if no such option was specified, over the list of generators given by the CPACK_GENERATOR variable set in the CPackConfig.cmake input file. • foreach generator, it then • sets CPACK_GENERATOR to the one currently being iterated • includes the CPACK_PROJECT_CONFIG_FILE • produces the package for that generator This is the key: For each generator listed in CPACK_GENERATOR in CPackConfig.cmake, cpack will reset CPACK_GENERATOR internally to the one cur‐ rently being used and then include the CPACK_PROJECT_CONFIG_FILE. Variables common to all CPack Generators Before including this CPack module in your CMakeLists.txt file, there are a variety of variables that can be set to customize the resulting in‐ stallers. The most commonly-used variables are: CPACK_PACKAGE_NAME The name of the package (or application). If not specified, it defaults to the project name. CPACK_PACKAGE_VENDOR The name of the package vendor. (e.g., “Kitware”). The default is “Humanity”. CPACK_PACKAGE_DIRECTORY The directory in which CPack is doing its packaging. If it is not set then this will default (internally) to the build dir. This variable may be defined in a CPack config file or from the cpack command line option -B. If set, the command line option overrides the value found in the config file. CPACK_PACKAGE_VERSION_MAJOR Package major version. This variable will always be set, but its default value depends on whether or not version details were given to the project() command in the top level CMakeLists.txt file. If version details were given, the default value will be CMAKE_PROJECT_VERSION_MA‐ JOR. If no version details were given, a default version of 0.1.1 will be assumed, leading to CPACK_PACKAGE_VERSION_MAJOR having a default value of 0. CPACK_PACKAGE_VERSION_MINOR Package minor version. The default value is determined based on whether or not version details were given to the project() command in the top level CMakeLists.txt file. If version details were given, the default value will be CMAKE_PROJECT_VERSION_MINOR, but if no minor ver‐ sion component was specified then CPACK_PACKAGE_VERSION_MINOR will be left unset. If no project version was given at all, a default ver‐ sion of 0.1.1 will be assumed, leading to CPACK_PACKAGE_VERSION_MINOR having a default value of 1. CPACK_PACKAGE_VERSION_PATCH Package patch version. The default value is determined based on whether or not version details were given to the project() command in the top level CMakeLists.txt file. If version details were given, the default value will be CMAKE_PROJECT_VERSION_PATCH, but if no patch ver‐ sion component was specified then CPACK_PACKAGE_VERSION_PATCH will be left unset. If no project version was given at all, a default ver‐ sion of 0.1.1 will be assumed, leading to CPACK_PACKAGE_VERSION_PATCH having a default value of 1. A description of the project, used in places such as the introduction screen of CPack-generated Windows installers. If not set, the value SCRIPTION_FILE points to a built-in template file Templates/CPack.GenericDescription.txt. otherwise the default will be a string generated by CMake based on CMAKE_PROJECT_NAME. CPACK_PACKAGE_HOMEPAGE_URL Project homepage URL. The default value is taken from the CMAKE_PROJECT_HOMEPAGE_URL variable, which is set by the top level project() command, or else the default will be empty if no URL was provided to project(). CPACK_PACKAGE_FILE_NAME The name of the package file to generate, not including the extension. For example, cmake-2.6.1-Linux-i686. The default value is: ${CPACK_PACKAGE_NAME}-${CPACK_PACKAGE_VERSION}-${CPACK_SYSTEM_NAME} CPACK_PACKAGE_INSTALL_DIRECTORY Installation directory on the target system. This may be used by some CPack generators like NSIS to create an installation directory e.g., “CMake 2.5” below the installation prefix. All installed elements will be put inside this directory. CPACK_PACKAGE_ICON A branding image that will be displayed inside the installer (used by GUI installers). CPACK_PACKAGE_CHECKSUM An algorithm that will be used to generate an additional file with the checksum of the package. The output file name will be: ${CPACK_PACKAGE_FILE_NAME}.${CPACK_PACKAGE_CHECKSUM} Supported algorithms are those listed by the string(<HASH>) command. CPACK_PROJECT_CONFIG_FILE CPack-time project CPack configuration file. This file is included at cpack time, once per generator after CPack has set CPACK_GENERATOR to the actual generator being used. It allows per-generator setting of CPACK_* variables at cpack time. CPACK_RESOURCE_FILE_LICENSE License to be embedded in the installer. It will typically be displayed to the user by the produced installer (often with an explicit “Ac‐ cept” button, for graphical installers) prior to installation. This license file is NOT added to the installed files but is used by some CPack generators like NSIS. If you want to install a license file (may be the same as this one) along with your project, you must add an appropriate CMake install() command in your CMakeLists.txt. CPACK_RESOURCE_FILE_README ReadMe file to be embedded in the installer. It typically describes in some detail the purpose of the project during the installation. Not all CPack generators use this file. CPACK_RESOURCE_FILE_WELCOME Welcome file to be embedded in the installer. It welcomes users to this installer. Typically used in the graphical installers on Windows and Mac OS X. CPACK_MONOLITHIC_INSTALL Disables the component-based installation mechanism. When set, the component specification is ignored and all installed items are put in a single “MONOLITHIC” package. Some CPack generators do monolithic packaging by default and may be asked to do component packaging by set‐ ting CPACK_<GENNAME>_COMPONENT_INSTALL to TRUE. CPACK_GENERATOR List of CPack generators to use. If not specified, CPack will create a set of options following the naming pattern CPACK_BINARY_<GENNAME> (e.g. CPACK_BINARY_NSIS) allowing the user to enable/disable individual generators. If the -G option is given on the cpack command line, it will override this variable and any CPACK_BINARY_<GENNAME> options. CPACK_OUTPUT_CONFIG_FILE The name of the CPack binary configuration file. This file is the CPack configuration generated by the CPack module for binary installers. Defaults to CPackConfig.cmake. CPACK_PACKAGE_EXECUTABLES Lists each of the executables and associated text label to be used to create Start Menu shortcuts. For example, setting this to the list ccmake;CMake will create a shortcut named “CMake” that will execute the installed executable ccmake. Not all CPack generators use it (at least NSIS, WIX and OSXX11 do). CPACK_STRIP_FILES List of files to be stripped. Starting with CMake 2.6.0, CPACK_STRIP_FILES will be a boolean variable which enables stripping of all files (a list of files evaluates to TRUE in CMake, so this change is compatible). CPACK_VERBATIM_VARIABLES If set to TRUE, values of variables prefixed with CPACK_ will be escaped before being written to the configuration files, so that the cpack program receives them exactly as they were specified. If not, characters like quotes and backslashes can cause parsing errors or alter the value received by the cpack program. Defaults to FALSE for backwards compatibility. Variables for Source Package Generators The following CPack variables are specific to source packages, and will not affect binary packages: CPACK_SOURCE_PACKAGE_FILE_NAME The name of the source package. For example cmake-2.6.1. CPACK_SOURCE_STRIP_FILES List of files in the source tree that will be stripped. Starting with CMake 2.6.0, CPACK_SOURCE_STRIP_FILES will be a boolean variable which enables stripping of all files (a list of files evaluates to TRUE in CMake, so this change is compatible). CPACK_SOURCE_GENERATOR List of generators used for the source packages. As with CPACK_GENERATOR, if this is not specified then CPack will create a set of options (e.g. CPACK_SOURCE_ZIP) allowing users to select which packages will be generated. CPACK_SOURCE_OUTPUT_CONFIG_FILE The name of the CPack source configuration file. This file is the CPack configuration generated by the CPack module for source installers. Defaults to CPackSourceConfig.cmake. CPACK_SOURCE_IGNORE_FILES Pattern of files in the source tree that won’t be packaged when building a source package. This is a list of regular expression patterns (that must be properly escaped), e.g., /CVS/;/\.svn/;\.swp$;\.#;/#;.*~;cscope.* Variables for Advanced Use The following variables are for advanced uses of CPack: CPACK_CMAKE_GENERATOR What CMake generator should be used if the project is a CMake project. Defaults to the value of CMAKE_GENERATOR. Few users will want to change this setting. CPACK_INSTALL_CMAKE_PROJECTS List of four values that specify what project to install. The four values are: Build directory, Project Name, Project Component, Direc‐ tory. If omitted, CPack will build an installer that installs everything. CPACK_SYSTEM_NAME System name, defaults to the value of CMAKE_SYSTEM_NAME, except on Windows where it will be win32 or win64. CPACK_PACKAGE_VERSION Package full version, used internally. By default, this is built from CPACK_PACKAGE_VERSION_MAJOR, CPACK_PACKAGE_VERSION_MINOR, and CPACK_PACKAGE_VERSION_PATCH. CPACK_TOPLEVEL_TAG Directory for the installed files. CPACK_INSTALL_COMMANDS Extra commands to install components. The environment variable CMAKE_INSTALL_PREFIX is set to the temporary install directory during exe‐ cution. CPACK_INSTALL_SCRIPTS Extra CMake scripts executed by CPack during its local staging installation, which is done right before packaging the files. The scripts are not called by a standalone install (e.g.: make install). For every script, the following variables will be set: CMAKE_CUR‐ RENT_SOURCE_DIR, CMAKE_CURRENT_BINARY_DIR and CMAKE_INSTALL_PREFIX (which is set to the staging install directory). The singular form CMAKE_INSTALL_SCRIPT is supported as an alternative variable for historical reasons, but its value is ignored if CMAKE_INSTALL_SCRIPTS is set and a warning will be issued. CPACK_INSTALLED_DIRECTORIES Extra directories to install. CPACK_PACKAGE_INSTALL_REGISTRY_KEY Registry key used when installing this project. This is only used by installers for Windows. The default value is based on the installa‐ tion directory. CPACK_CREATE_DESKTOP_LINKS List of desktop links to create. Each desktop link requires a corresponding start menu shortcut as created by CPACK_PACKAGE_EXECUTABLES. CPACK_BINARY_<GENNAME> CPack generated options for binary generators. The CPack.cmake module generates (when CPACK_GENERATOR is not set) a set of CMake options (see CMake option() command) which may then be used to select the CPack generator(s) to be used when building the package target or when running cpack without the -G option. CSharpUtilities Functions to make configuration of CSharp/.NET targets easier. A collection of CMake utility functions useful for dealing with CSharp targets for Visual Studio generators from version 2010 and later. The following functions are provided by this module: Main functions • csharp_set_windows_forms_properties() • csharp_set_designer_cs_properties() • csharp_set_xaml_cs_properties() Helper functions • csharp_get_filename_keys() • csharp_get_filename_key_base() • csharp_get_dependentupon_name() Main functions provided by the module csharp_set_windows_forms_properties Sets source file properties for use of Windows Forms. Use this, if your CSharp target uses Windows Forms: csharp_set_windows_forms_properties([<file1> [<file2> [...]]]) <fileN> List of all source files which are relevant for setting the VS_CSHARP_<tagname> properties (including .cs, .resx and .Designer.cs extensions). In the list of all given files for all files ending with .Designer.cs and .resx is searched. For every designer or resource file a file with the same base name but only .cs as extension is searched. If this is found, the VS_CSHARP_<tagname> properties are set as follows: for the .cs file: • VS_CSHARP_SubType “Form” for the .Designer.cs file (if it exists): • VS_CSHARP_DependentUpon <cs-filename> • VS_CSHARP_DesignTime “” (delete tag if previously defined) • VS_CSHARP_AutoGen “”(delete tag if previously defined) for the .resx file (if it exists): • VS_RESOURCE_GENERATOR “” (delete tag if previously defined) • VS_CSHARP_DependentUpon <cs-filename> • VS_CSHARP_SubType “Designer” csharp_set_designer_cs_properties Sets source file properties of .Designer.cs files depending on sibling filenames. Use this, if your CSharp target does not use Windows Forms (for Windows Forms use csharp_set_designer_cs_properties() instead): csharp_set_designer_cs_properties([<file1> [<file2> [...]]]) <fileN> List of all source files which are relevant for setting the VS_CSHARP_<tagname> properties (including .cs, .resx, .settings and .De‐ signer.cs extensions). In the list of all given files for all files ending with .Designer.cs is searched. For every designer file all files with the same base name but different extensions are searched. If a match is found, the source file properties of the designer file are set depending on the extension of the matched file: if match is .resx file: • VS_CSHARP_AutoGen “True” • VS_CSHARP_DesignTime “True” • VS_CSHARP_DependentUpon <resx-filename> if match is .cs file: • VS_CSHARP_DependentUpon <cs-filename> if match is .settings file: • VS_CSHARP_AutoGen “True” • VS_CSHARP_DesignTimeSharedInput “True” • VS_CSHARP_DependentUpon <settings-filename> NOTE: Because the source file properties of the .Designer.cs file are set according to the found matches and every match sets the VS_CSHARP_Dependen‐ tUpon property, there should only be one match for each Designer.cs file. csharp_set_xaml_cs_properties Sets source file properties for use of Windows Presentation Foundation (WPF) and XAML. Use this, if your CSharp target uses WPF/XAML: csharp_set_xaml_cs_properties([<file1> [<file2> [...]]]) <fileN> List of all source files which are relevant for setting the VS_CSHARP_<tagname> properties (including .cs, .xaml, and .xaml.cs ex‐ tensions). In the list of all given files for all files ending with .xaml.cs is searched. For every xaml-cs file, a file with the same base name but extension .xaml is searched. If a match is found, the source file properties of the .xaml.cs file are set: • VS_CSHARP_DependentUpon <xaml-filename> Helper functions which are used by the above ones csharp_get_filename_keys Helper function which computes a list of key values to identify source files independently of relative/absolute paths given in cmake and eliminates case sensitivity: csharp_get_filename_keys(OUT [<file1> [<file2> [...]]]) OUT Name of the variable in which the list of keys is stored <fileN> filename(s) as given to to CSharp target using add_library() or add_executable() In some way the function applies a canonicalization to the source names. This is necessary to find file matches if the files have been added to the target with different directory prefixes: add_library(lib myfile.cs ${CMAKE_CURRENT_SOURCE_DIR}/myfile.Designer.cs) set_source_files_properties(myfile.Designer.cs PROPERTIES VS_CSHARP_DependentUpon myfile.cs) # this will fail, because in cmake # - ${CMAKE_CURRENT_SOURCE_DIR}/myfile.Designer.cs # - myfile.Designer.cs # are not the same source file. The source file property is not set. csharp_get_filename_key_base Returns the full filepath and name without extension of a key. KEY is expected to be a key from csharp_get_filename_keys. In BASE the value of KEY without the file extension is returned: csharp_get_filename_key_base(BASE KEY) BASE Name of the variable with the computed “base” of KEY. KEY The key of which the base will be computed. Expected to be a upper case full filename. csharp_get_dependentupon_name Computes a string which can be used as value for the source file property VS_CSHARP_<tagname> with target being DependentUpon: csharp_get_dependentupon_name(NAME FILE) NAME Name of the variable with the result value FILE Filename to convert to <DependentUpon> value Actually this is only the filename without any path given at the moment. CTest Configure a project for testing with CTest/CDash Include this module in the top CMakeLists.txt file of a project to enable testing with CTest and dashboard submissions to CDash: project(MyProject) ... include(CTest) The module automatically creates a BUILD_TESTING option that selects whether to enable testing support (ON by default). After including the mod‐ ule, use code like: if(BUILD_TESTING) # ... CMake code to create tests ... endif() to creating tests when testing is enabled. To enable submissions to a CDash server, create a CTestConfig.cmake file at the top of the project with content such as: set(CTEST_NIGHTLY_START_TIME 01:00:00 UTC) set(CTEST_SUBMIT_URL http://my.cdash.org/submit.php?project=MyProject) (the CDash server can provide the file to a project administrator who configures MyProject). Settings in the config file are shared by both this CTest module and the ctest(1) command-line Dashboard Client mode (ctest -S). While building a project for submission to CDash, CTest scans the build output for errors and warnings and reports them with surrounding context from the build log. This generic approach works for all build tools, but does not give details about the command invocation that produced a given problem. One may get more detailed reports by setting the CTEST_USE_LAUNCHERS variable: set(CTEST_USE_LAUNCHERS 1) in the CTestConfig.cmake file. CTestCoverageCollectGCOV This module provides the ctest_coverage_collect_gcov function. This function runs gcov on all .gcda files found in the binary tree and packages the resulting .gcov files into a tar file. This tarball also contains the following: • data.json defines the source and build directories for use by CDash. • Labels.json indicates any LABELS that have been set on the source files. • The uncovered directory holds any uncovered files found by CTEST_EXTRA_COVERAGE_GLOB. After generating this tar file, it can be sent to CDash for display with the ctest_submit(CDASH_UPLOAD) command. ctest_coverage_collect_gcov ctest_coverage_collect_gcov(TARBALL <tarfile> [SOURCE <source_dir>][BUILD <build_dir>] [GCOV_COMMAND <gcov_command>] package type is used in an output string. If not set, the string “<TYPE> packages” is used. Functions feature_summary feature_summary( [FILENAME <file>] [APPEND] [VAR <variable_name>] [INCLUDE_QUIET_PACKAGES] [FATAL_ON_MISSING_REQUIRED_PACKAGES] [QUIET_ON_EMPTY] WHAT (ALL | PACKAGES_FOUND | PACKAGES_NOT_FOUND | <TYPE>_PACKAGES_FOUND | <TYPE>_PACKAGES_NOT_FOUND | ENABLED_FEATURES | DISABLED_FEATURES) ) The feature_summary() macro can be used to print information about enabled or disabled packages or features of a project. By default, only the names of the features/packages will be printed and their required version when one was specified. Use set_package_properties() to add more useful information, like e.g. a download URL for the respective package or their purpose in the project. The WHAT option is the only mandatory option. Here you specify what information will be printed: ALL print everything ENABLED_FEATURES the list of all features which are enabled DISABLED_FEATURES the list of all features which are disabled PACKAGES_FOUND the list of all packages which have been found PACKAGES_NOT_FOUND the list of all packages which have not been found For each package type <TYPE> defined by the FeatureSummary_PKG_TYPES global property, the following information can also be used: <TYPE>_PACKAGES_FOUND only those packages which have been found which have the type <TYPE> <TYPE>_PACKAGES_NOT_FOUND only those packages which have not been found which have the type <TYPE> With the exception of the ALL value, these values can be combined in order to customize the output. For example: feature_summary(WHAT ENABLED_FEATURES DISABLED_FEATURES) If a FILENAME is given, the information is printed into this file. If APPEND is used, it is appended to this file, otherwise the file is overwritten if it already existed. If the VAR option is used, the information is “printed” into the specified variable. If FILENAME is printed above the actual content. If only one type of package was requested, no title is printed, unless it is explicitly set using either given, packages which have been searched with find_package(... QUIET) will also be listed. By default they are skipped. If FATAL_ON_MISS‐ ING_REQUIRED_PACKAGES is given, CMake will abort if a package which is marked as one of the package types listed in the FeatureSummary_REQUIRED_PKG_TYPES global property has not been found. The default value for the FeatureSummary_REQUIRED_PKG_TYPES global property is REQUIRED. The FeatureSummary_DEFAULT_PKG_TYPE global property can be modified to change the default package type assigned when not explicitly as‐ signed by the user. If the QUIET_ON_EMPTY option is used, if only one type of package was requested, and no packages belonging to that category were found, Example 1, append everything to a file: include(FeatureSummary) feature_summary(WHAT ALL FILENAME ${CMAKE_BINARY_DIR}/all.log APPEND) Example 2, print the enabled features into the variable enabledFeaturesText, including QUIET packages: include(FeatureSummary) feature_summary(WHAT ENABLED_FEATURES INCLUDE_QUIET_PACKAGES VAR enabledFeaturesText) message(STATUS ${enabledFeaturesText}) Example 3, change default package types and print only the categories that are not empty: include(FeatureSummary) set_property(GLOBAL APPEND PROPERTY FeatureSummary_PKG_TYPES BUILD) find_package(FOO) set_package_properties(FOO PROPERTIES TYPE BUILD) feature_summary(WHAT BUILD_PACKAGES_FOUND Description Build tools found: QUIET_ON_EMPTY) feature_summary(WHAT BUILD_PACKAGES_NOT_FOUND Description Build tools not found: QUIET_ON_EMPTY) set_package_properties set_package_properties(<name> PROPERTIES [ URL <url> ] [ TYPE (RUNTIME|OPTIONAL|RECOMMENDED|REQUIRED) ] [ PURPOSE <purpose> ] ) Use this macro to set up information about the named package, which can then be displayed via FEATURE_SUMMARY(). This can be done either directly in the Find-module or in the project which uses the module after the find_package() call. The features for which information can be set are added automatically by the find_package() command. URL <url> This should be the homepage of the package, or something similar. Ideally this is set already directly in the Find-module. A short description what that package is, at most one sentence. Ideally this is set already directly in the Find-module. TYPE <type> What type of dependency has the using project on that package. Default is OPTIONAL. In this case it is a package which can be used by the project when available at buildtime, but it also work without. RECOMMENDED is similar to OPTIONAL, i.e. the project will build if the package is not present, but the functionality of the resulting binaries will be severely limited. If a REQUIRED pack‐ age is not available at buildtime, the project may not even build. This can be combined with the FATAL_ON_MISSING_REQUIRED_PACKAGES argument for feature_summary(). Last, a RUNTIME package is a package which is actually not used at all during the build, but which is required for actually running the resulting binaries. So if such a package is missing, the project can still be built, but it may not work later on. If set_package_properties() is called multiple times for the same package with different TYPEs, the TYPE is only changed to higher TYPEs (RUNTIME < OPTIONAL < RECOMMENDED < REQUIRED), lower TYPEs are ignored. The TYPE property is project-specific, so it cannot be set by the Find-module, but must be set in the project. Type accepted can be changed by setting the FeatureSummary_PKG_TYPES global property. PURPOSE <purpose> This describes which features this package enables in the project, i.e. it tells the user what functionality he gets in the result‐ ing binaries. If set_package_properties() is called multiple times for a package, all PURPOSE properties are appended to a list of purposes of the package in the project. As the TYPE property, also the PURPOSE property is project-specific, so it cannot be set by the Find-module, but must be set in the project. Example for setting the info for a package: find_package(LibXml2) set_package_properties(LibXml2 PROPERTIES URL http://xmlsoft.org/) # or set_package_properties(LibXml2 PROPERTIES TYPE RECOMMENDED PURPOSE Enables HTML-import in MyWordProcessor) # or set_package_properties(LibXml2 PROPERTIES TYPE OPTIONAL PURPOSE Enables odt-export in MyWordProcessor) find_package(DBUS) set_package_properties(DBUS PROPERTIES TYPE RUNTIME PURPOSE Necessary to disable the screensaver during a presentation) add_feature_info add_feature_info(<name> <enabled> <description>) Use this macro to add information about a feature with the given <name>. <enabled> contains whether this feature is enabled or not. It can be a variable or a list of conditions. <description> is a text describing the feature. The information can be displayed using fea‐ ture_summary() for ENABLED_FEATURES and DISABLED_FEATURES respectively. Example for setting the info for a feature: option(WITH_FOO Help for foo ON) add_feature_info(Foo WITH_FOO The Foo feature provides very cool stuff.) Legacy Macros The following macros are provided for compatibility with previous CMake versions: set_package_info set_package_info(<name> <description> [ <url> [<purpose>] ]) Use this macro to set up information about the named package, which can then be displayed via feature_summary(). This can be done either directly in the Find-module or in the project which uses the module after the find_package() call. The features for which information can be set are added automatically by the find_package() command. set_feature_info set_feature_info(<name> <description> [<url>]) Does the same as: set_package_info(<name> <description> <url>) print_enabled_features print_enabled_features() Does the same as print_disabled_features print_disabled_features() Does the same as FetchContent Overview This module enables populating content at configure time via any method supported by the ExternalProject module. Whereas ExternalProject_Add() downloads at build time, the FetchContent module makes content available immediately, allowing the configure step to use the content in commands like add_subdirectory(), include() or file() operations. Content population details would normally be defined separately from the command that performs the actual population. This separation ensures that all of the dependency details are defined before anything may try to use those details to populate content. This is particularly important in more complex project hierarchies where dependencies may be shared between multiple projects. The following shows a typical example of declaring content details: FetchContent_Declare( googletest GIT_REPOSITORY https://github.com/google/googletest.git GIT_TAG release-1.8.0 ) For most typical cases, populating the content can then be done with a single command like so: FetchContent_MakeAvailable(googletest) The above command not only populates the content, it also adds it to the main build (if possible) so that the main build can use the populated project’s targets, etc. In some cases, the main project may need to have more precise control over the population or may be required to explic‐ itly define the population steps (e.g. if CMake versions earlier than 3.14 need to be supported). The typical pattern of such custom steps looks like this: FetchContent_GetProperties(googletest) if(NOT googletest_POPULATED) FetchContent_Populate(googletest) add_subdirectory(${googletest_SOURCE_DIR} ${googletest_BINARY_DIR}) endif() Regardless of which population method is used, when using the declare-populate pattern with a hierarchical project arrangement, projects at higher levels in the hierarchy are able to override the population details of content specified anywhere lower in the project hierarchy. The ability to detect whether content has already been populated ensures that even if multiple child projects want certain content to be available, the first one to populate it wins. The other child project can simply make use of the already available content instead of repeating the population for itself. See the Examples section which demonstrates this scenario. The FetchContent module also supports defining and populating content in a single call, with no check for whether the content has been populated elsewhere in the project already. This is a more low level operation and would not normally be the way the module is used, but it is sometimes useful as part of implementing some higher level feature or to populate some content in CMake’s script mode. Declaring Content Details FetchContent_Declare FetchContent_Declare(<name> <contentOptions>...) The FetchContent_Declare() function records the options that describe how to populate the specified content, but if such details have al‐ ready been recorded earlier in this project (regardless of where in the project hierarchy), this and all later calls for the same content <name> are ignored. This “first to record, wins” approach is what allows hierarchical projects to have parent projects override content details of child projects. The content <name> can be any string without spaces, but good practice would be to use only letters, numbers and underscores. The name will be treated case-insensitively and it should be obvious for the content it represents, often being the name of the child project or the value given to its top level project() command (if it is a CMake project). For well-known public projects, the name should generally be the official name of the project. Choosing an unusual name makes it unlikely that other projects needing that same content will use the same name, leading to the content being populated multiple times. The <contentOptions> can be any of the download or update/patch options that the ExternalProject_Add() command understands. The configure, build, install and test steps are explicitly disabled and therefore options related to them will be ignored. In most cases, <contentOp‐ tions> will just be a couple of options defining the download method and method-specific details like a commit tag or archive hash. For example: FetchContent_Declare( googletest GIT_REPOSITORY https://github.com/google/googletest.git GIT_TAG release-1.8.0 ) FetchContent_Declare( myCompanyIcons URL https://intranet.mycompany.com/assets/iconset_1.12.tar.gz URL_HASH 5588a7b18261c20068beabfb4f530b87 ) FetchContent_Declare( myCompanyCertificates SVN_REPOSITORY svn+ssh://svn.mycompany.com/srv/svn/trunk/certs SVN_REVISION -r12345 ) Populating The Content For most common scenarios, population means making content available to the main build according to previously declared details for that depen‐ dency. There are two main patterns for populating content, one based on calling FetchContent_GetProperties() and FetchContent_Populate() for more precise control and the other on calling FetchContent_MakeAvailable() for a simpler, more automated approach. The former generally follows this canonical pattern: # Check if population has already been performed FetchContent_GetProperties(<name>) string(TOLOWER <name> lcName) if(NOT ${lcName}_POPULATED) # Fetch the content using previously declared details FetchContent_Populate(<name>) # Set custom variables, policies, etc. # ... # Bring the populated content into the build add_subdirectory(${${lcName}_SOURCE_DIR} ${${lcName}_BINARY_DIR}) endif() The above is such a common pattern that, where no custom steps are needed between the calls to FetchContent_Populate() and add_subdirectory(), equivalent logic can be obtained by calling FetchContent_MakeAvailable() instead (and should be preferred where it meets the needs of the project). FetchContent_Populate FetchContent_Populate( <name> ) In most cases, the only argument given to FetchContent_Populate() is the <name>. When used this way, the command assumes the content de‐ tails have been recorded by an earlier call to FetchContent_Declare(). The details are stored in a global property, so they are unaffected by things like variable or directory scope. Therefore, it doesn’t matter where in the project the details were previously declared, as long as they have been declared before the call to FetchContent_Populate(). Those saved details are then used to construct a call to Ex‐ ternalProject_Add() in a private sub-build to perform the content population immediately. The implementation of ExternalProject_Add() en‐ sures that if the content has already been populated in a previous CMake run, that content will be reused rather than repopulating them again. For the common case where population involves downloading content, the cost of the download is only paid once. An internal global property records when a particular content population request has been processed. If FetchContent_Populate() is called more than once for the same content name within a configure run, the second call will halt with an error. Projects can and should check whether content population has already been processed with the FetchContent_GetProperties() command before calling FetchContent_Populate(). FetchContent_Populate() will set three variables in the scope of the caller; <lcName>_POPULATED, <lcName>_SOURCE_DIR and <lcName>_BI‐ NARY_DIR, where <lcName> is the lowercased <name>. <lcName>_POPULATED will always be set to True by the call. <lcName>_SOURCE_DIR is the location where the content can be found upon return (it will have already been populated), while <lcName>_BINARY_DIR is a directory in‐ tended for use as a corresponding build directory. The main use case for the two directory variables is to call add_subdirectory() immedi‐ ately after population, i.e.: FetchContent_Populate(FooBar ...) add_subdirectory(${foobar_SOURCE_DIR} ${foobar_BINARY_DIR}) The values of the three variables can also be retrieved from anywhere in the project hierarchy using the FetchContent_GetProperties() com‐ mand. A number of cache variables influence the behavior of all content population performed using details saved from a FetchContent_Declare() call: FETCHCONTENT_BASE_DIR In most cases, the saved details do not specify any options relating to the directories to use for the internal sub-build, final source and build areas. It is generally best to leave these decisions up to the FetchContent module to handle on the project’s be‐ half. The FETCHCONTENT_BASE_DIR cache variable controls the point under which all content population directories are collected, but in most cases developers would not need to change this. The default location is ${CMAKE_BINARY_DIR}/_deps, but if developers change this value, they should aim to keep the path short and just below the top level of the build tree to avoid running into path length problems on Windows. FETCHCONTENT_QUIET The logging output during population can be quite verbose, making the configure stage quite noisy. This cache option (ON by de‐ fault) hides all population output unless an error is encountered. If experiencing problems with hung downloads, temporarily switching this option off may help diagnose which content population is causing the issue. FETCHCONTENT_FULLY_DISCONNECTED When this option is enabled, no attempt is made to download or update any content. It is assumed that all content has already been populated in a previous run or the source directories have been pointed at existing contents the developer has provided manually (using options described further below). When the developer knows that no changes have been made to any content details, turning this option ON can significantly speed up the configure stage. It is OFF by default. FETCHCONTENT_UPDATES_DISCONNECTED This is a less severe download/update control compared to FETCHCONTENT_FULLY_DISCONNECTED. Instead of bypassing all download and update logic, the FETCHCONTENT_UPDATES_DISCONNECTED only disables the update stage. Therefore, if content has not been downloaded previously, it will still be downloaded when this option is enabled. This can speed up the configure stage, but not as much as FETCHCONTENT_FULLY_DISCONNECTED. It is OFF by default. In addition to the above cache variables, the following cache variables are also defined for each content name (<ucName> is the uppercased value of <name>): FETCHCONTENT_SOURCE_DIR_<ucName> If this is set, no download or update steps are performed for the specified content and the <lcName>_SOURCE_DIR variable returned to the caller is pointed at this location. This gives developers a way to have a separate checkout of the content that they can modify freely without interference from the build. The build simply uses that existing source, but it still defines <lcName>_BINARY_DIR to point inside its own build area. Developers are strongly encouraged to use this mechanism rather than editing the sources populated in the default location, as changes to sources in the default location can be lost when content population details are changed by the project. FETCHCONTENT_UPDATES_DISCONNECTED_<ucName> This is the per-content equivalent of FETCHCONTENT_UPDATES_DISCONNECTED. If the global option or this option is ON, then updates will be disabled for the named content. Disabling updates for individual content can be useful for content whose details rarely change, while still leaving other frequently changing content with updates enabled. The FetchContent_Populate() command also supports a syntax allowing the content details to be specified directly rather than using any saved details. This is more low-level and use of this form is generally to be avoided in favour of using saved content details as outlined above. Nevertheless, in certain situations it can be useful to invoke the content population as an isolated operation (typically as part of implementing some other higher level feature or when using CMake in script mode): FetchContent_Populate( <name> [QUIET] [SUBBUILD_DIR <subBuildDir>] [SOURCE_DIR <srcDir>] [BINARY_DIR <binDir>] ... ) This form has a number of key differences to that where only <name> is provided: • All required population details are assumed to have been provided directly in the call to FetchContent_Populate(). Any saved details for <name> are ignored. • No check is made for whether content for <name> has already been populated. • No global property is set to record that the population has occurred. • No global properties record the source or binary directories used for the populated content. • The FETCHCONTENT_FULLY_DISCONNECTED and FETCHCONTENT_UPDATES_DISCONNECTED cache variables are ignored. The <lcName>_SOURCE_DIR and <lcName>_BINARY_DIR variables are still returned to the caller, but since these locations are not stored as global properties when this form is used, they are only available to the calling scope and below rather than the entire project hierarchy. No <lcName>_POPULATED variable is set in the caller’s scope with this form. The supported options for FetchContent_Populate() are the same as those for FetchContent_Declare(). Those few options shown just above are either specific to FetchContent_Populate() or their behavior is slightly modified from how ExternalProject_Add() treats them. QUIET The QUIET option can be given to hide the output associated with populating the specified content. If the population fails, the output will be shown regardless of whether this option was given or not so that the cause of the failure can be diagnosed. The global FETCHCONTENT_QUIET cache variable has no effect on FetchContent_Populate() calls where the content details are provided di‐ rectly. SUBBUILD_DIR The SUBBUILD_DIR argument can be provided to change the location of the sub-build created to perform the population. The default value is ${CMAKE_CURRENT_BINARY_DIR}/<lcName>-subbuild and it would be unusual to need to override this default. If a relative path is specified, it will be interpreted as relative to CMAKE_CURRENT_BINARY_DIR. SOURCE_DIR, BINARY_DIR The SOURCE_DIR and BINARY_DIR arguments are supported by ExternalProject_Add(), but different default values are used by FetchCon‐ tent_Populate(). SOURCE_DIR defaults to ${CMAKE_CURRENT_BINARY_DIR}/<lcName>-src and BINARY_DIR defaults to ${CMAKE_CURRENT_BI‐ NARY_DIR}/<lcName>-build. If a relative path is specified, it will be interpreted as relative to CMAKE_CURRENT_BINARY_DIR. In addition to the above explicit options, any other unrecognized options are passed through unmodified to ExternalProject_Add() to perform the download, patch and update steps. The following options are explicitly prohibited (they are disabled by the FetchContent_Populate() command): • CONFIGURE_COMMAND • BUILD_COMMAND • INSTALL_COMMAND • TEST_COMMAND If using FetchContent_Populate() within CMake’s script mode, be aware that the implementation sets up a sub-build which therefore requires a CMake generator and build tool to be available. If these cannot be found by default, then the CMAKE_GENERATOR and/or CMAKE_MAKE_PROGRAM variables will need to be set appropriately on the command line invoking the script. FetchContent_GetProperties When using saved content details, a call to FetchContent_Populate() records information in global properties which can be queried at any time. This information includes the source and binary directories associated with the content and also whether or not the content popula‐ tion has been processed during the current configure run. FetchContent_GetProperties( <name> [SOURCE_DIR <srcDirVar>] [BINARY_DIR <binDirVar>] [POPULATED <doneVar>] ) The SOURCE_DIR, BINARY_DIR and POPULATED options can be used to specify which properties should be retrieved. Each option accepts a value which is the name of the variable in which to store that property. Most of the time though, only <name> is given, in which case the call will then set the same variables as a call to FetchContent_Populate(name). This allows the following canonical pattern to be used, which ensures that the relevant variables will always be defined regardless of whether or not the population has been performed elsewhere in the project already: FetchContent_GetProperties(foobar) if(NOT foobar_POPULATED) FetchContent_Populate(foobar) ... endif() The above pattern allows other parts of the overall project hierarchy to re-use the same content and ensure that it is only populated once. FetchContent_MakeAvailable FetchContent_MakeAvailable( <name1> [<name2>...] ) This command implements the common pattern typically needed for most dependencies. It iterates over each of the named dependencies in turn and for each one it loosely follows the same canonical pattern as presented at the beginning of this section. One small difference to that pattern is that it will only call add_subdirectory() on the populated content if there is a CMakeLists.txt file in its top level source di‐ rectory. This allows the command to be used for dependencies that make downloaded content available at a known location but which do not need or support being added directly to the build. Examples This first fairly straightforward example ensures that some popular testing frameworks are available to the main build: include(FetchContent) FetchContent_Declare( googletest GIT_REPOSITORY https://github.com/google/googletest.git GIT_TAG release-1.8.0 ) FetchContent_Declare( Catch2 GIT_REPOSITORY https://github.com/catchorg/Catch2.git GIT_TAG v2.5.0 ) # After the following call, the CMake targets defined by googletest and # Catch2 will be defined and available to the rest of the build FetchContent_MakeAvailable(googletest Catch2) In more complex project hierarchies, the dependency relationships can be more complicated. Consider a hierarchy where projA is the top level project and it depends directly on projects projB and projC. Both projB and projC can be built standalone and they also both depend on another project projD. projB additionally depends on projE. This example assumes that all five projects are available on a company git server. The CMakeLists.txt of each project might have sections like the following: projA: include(FetchContent) FetchContent_Declare( projB GIT_REPOSITORY git@mycompany.com:git/projB.git GIT_TAG 4a89dc7e24ff212a7b5167bef7ab079d ) FetchContent_Declare( projC GIT_REPOSITORY git@mycompany.com:git/projC.git GIT_TAG 4ad4016bd1d8d5412d135cf8ceea1bb9 ) FetchContent_Declare( projD GIT_REPOSITORY git@mycompany.com:git/projD.git GIT_TAG origin/integrationBranch ) FetchContent_Declare( projE GIT_REPOSITORY git@mycompany.com:git/projE.git GIT_TAG origin/release/2.3-rc1 ) # Order is important, see notes in the discussion further below FetchContent_MakeAvailable(projD projB projC) projB: include(FetchContent) FetchContent_Declare( projD GIT_REPOSITORY git@mycompany.com:git/projD.git GIT_TAG 20b415f9034bbd2a2e8216e9a5c9e632 ) FetchContent_Declare( projE GIT_REPOSITORY git@mycompany.com:git/projE.git GIT_TAG 68e20f674a48be38d60e129f600faf7d ) FetchContent_MakeAvailable(projD projE) projC: include(FetchContent) FetchContent_Declare( projD GIT_REPOSITORY git@mycompany.com:git/projD.git GIT_TAG 7d9a17ad2c962aa13e2fbb8043fb6b8a ) # This particular version of projD requires workarounds FetchContent_GetProperties(projD) if(NOT projd_POPULATED) FetchContent_Populate(projD) # Copy an additional/replacement file into the populated source file(COPY someFile.c DESTINATION ${projd_SOURCE_DIR}/src) add_subdirectory(${projd_SOURCE_DIR} ${projd_BINARY_DIR}) endif() A few key points should be noted in the above: • projB and projC define different content details for projD, but projA also defines a set of content details for projD. Because projA will de‐ fine them first, the details from projB and projC will not be used. The override details defined by projA are not required to match either of those from projB or projC, but it is up to the higher level project to ensure that the details it does define still make sense for the child projects. • In the projA call to FetchContent_MakeAvailable(), projD is listed ahead of projB and projC to ensure that projA is in control of how projD is populated. • While projA defines content details for projE, it does not need to explicitly call FetchContent_MakeAvailable(projE) or FetchContent_Popu‐ late(projD) itself. Instead, it leaves that to the child projB. For higher level projects, it is often enough to just define the override con‐ tent details and leave the actual population to the child projects. This saves repeating the same thing at each level of the project hierarchy unnecessarily. Projects don’t always need to add the populated content to the build. Sometimes the project just wants to make the downloaded content available at a predictable location. The next example ensures that a set of standard company toolchain files (and potentially even the toolchain binaries themselves) is available early enough to be used for that same build. cmake_minimum_required(VERSION 3.14) include(FetchContent) FetchContent_Declare( mycom_toolchains URL https://intranet.mycompany.com//toolchains_1.3.2.tar.gz ) FetchContent_MakeAvailable(mycom_toolchains) project(CrossCompileExample) The project could be configured to use one of the downloaded toolchains like so: cmake -DCMAKE_TOOLCHAIN_FILE=_deps/mycom_toolchains-src/toolchain_arm.cmake /path/to/src When CMake processes the CMakeLists.txt file, it will download and unpack the tarball into _deps/mycompany_toolchains-src relative to the build directory. The CMAKE_TOOLCHAIN_FILE variable is not used until the project() command is reached, at which point CMake looks for the named toolchain file relative to the build directory. Because the tarball has already been downloaded and unpacked by then, the toolchain file will be in place, even the very first time that cmake is run in the build directory. Lastly, the following example demonstrates how one might download and unpack a firmware tarball using CMake’s script mode. The call to FetchContent_Populate() specifies all the content details and the unpacked firmware will be placed in a firmware directory below the current work‐ ing directory. getFirmware.cmake: # NOTE: Intended to be run in script mode with cmake -P include(FetchContent) FetchContent_Populate( firmware URL https://mycompany.com/assets/firmware-1.23-arm.tar.gz URL_HASH MD5=68247684da89b608d466253762b0ff11 SOURCE_DIR firmware ) FindPackageHandleStandardArgs This module provides a function intended to be used in Find Modules implementing find_package(<PackageName>) calls. It handles the REQUIRED, QUIET and version-related arguments of find_package. It also sets the <PackageName>_FOUND variable. The package is considered found if all vari‐ ables listed contain valid results, e.g. valid filepaths. find_package_handle_standard_args There are two signatures: find_package_handle_standard_args(<PackageName> (DEFAULT_MSG|<custom-failure-message>) <required-var>... ) find_package_handle_standard_args(<PackageName> [FOUND_VAR <result-var>] [REQUIRED_VARS <required-var>...] [VERSION_VAR <version-var>] [HANDLE_COMPONENTS] [CONFIG_MODE] [REASON_FAILURE_MESSAGE <reason-failure-message>] [FAIL_MESSAGE <custom-failure-message>] ) The <PackageName>_FOUND variable will be set to TRUE if all the variables <required-var>... are valid and any optional constraints are sat‐ isfied, and FALSE otherwise. A success or failure message may be displayed based on the results and on whether the REQUIRED and/or QUIET option was given to the find_package() call. The options are: (DEFAULT_MSG|<custom-failure-message>) In the simple signature this specifies the failure message. Use DEFAULT_MSG to ask for a default message to be computed (recom‐ mended). Not valid in the full signature. FOUND_VAR <result-var> Obsolete. Specifies either <PackageName>_FOUND or <PACKAGENAME>_FOUND as the result variable. This exists only for compatibility with older versions of CMake and is now ignored. Result variables of both names are always set for compatibility. REQUIRED_VARS <required-var>... Specify the variables which are required for this package. These may be named in the generated failure message asking the user to set the missing variable values. Therefore these should typically be cache entries such as FOO_LIBRARY and not output variables like FOO_LIBRARIES. VERSION_VAR <version-var> Specify the name of a variable that holds the version of the package that has been found. This version will be checked against the (potentially) specified required version given to the find_package() call, including its EXACT option. The default messages include information about the required version and the version which has been actually found, both if the version is ok or not. HANDLE_COMPONENTS Enable handling of package components. In this case, the command will report which components have been found and which are miss‐ ing, and the <PackageName>_FOUND variable will be set to FALSE if any of the required components (i.e. not the ones listed after the OPTIONAL_COMPONENTS option of find_package()) are missing. CONFIG_MODE Specify that the calling find module is a wrapper around a call to find_package(<PackageName> NO_MODULE). This implies a VER‐ SION_VAR value of <PackageName>_VERSION. The command will automatically check whether the package configuration file was found. REASON_FAILURE_MESSAGE <reason-failure-message> Specify a custom message of the reason for the failure which will be appended to the default generated message. FAIL_MESSAGE <custom-failure-message> Specify a custom failure message instead of using the default generated message. Not recommended. Example for the simple signature: find_package_handle_standard_args(LibXml2 DEFAULT_MSG LIBXML2_LIBRARY LIBXML2_INCLUDE_DIR) The LibXml2 package is considered to be found if both LIBXML2_LIBRARY and LIBXML2_INCLUDE_DIR are valid. Then also LibXml2_FOUND is set to TRUE. If it is not found and REQUIRED was used, it fails with a message(FATAL_ERROR), independent whether QUIET was used or not. If it is found, suc‐ cess will be reported, including the content of the first <required-var>. On repeated CMake runs, the same message will not be printed again. Example for the full signature: find_package_handle_standard_args(LibArchive REQUIRED_VARS LibArchive_LIBRARY LibArchive_INCLUDE_DIR VERSION_VAR LibArchive_VERSION) In this case, the LibArchive package is considered to be found if both LibArchive_LIBRARY and LibArchive_INCLUDE_DIR are valid. Also the version of LibArchive will be checked by using the version contained in LibArchive_VERSION. Since no FAIL_MESSAGE is given, the default messages will be printed. Another example for the full signature: find_package(Automoc4 QUIET NO_MODULE HINTS /opt/automoc4) find_package_handle_standard_args(Automoc4 CONFIG_MODE) In this case, a FindAutmoc4.cmake module wraps a call to find_package(Automoc4 NO_MODULE) and adds an additional search directory for automoc4. Then the call to find_package_handle_standard_args produces a proper success/failure message. FindPackageMessage find_package_message(<name> message for user find result details) This function is intended to be used in FindXXX.cmake modules files. It will print a message once for each unique find result. This is useful for telling the user where a package was found. The first argument specifies the name (XXX) of the package. The second argument specifies the message to display. The third argument lists details about the find result so that if they change the message will be displayed again. The macro also obeys the QUIET argument to the find_package command. Example: if(X11_FOUND) find_package_message(X11 Found X11: ${X11_X11_LIB} [${X11_X11_LIB}][${X11_INCLUDE_DIR}]) else() ... endif() FortranCInterface Fortran/C Interface Detection This module automatically detects the API by which C and Fortran languages interact. Module Variables Variables that indicate if the mangling is found: FortranCInterface_GLOBAL_FOUND Global subroutines and functions. FortranCInterface_MODULE_FOUND Module subroutines and functions (declared by “MODULE PROCEDURE”). This module also provides the following variables to specify the detected mangling, though a typical use case does not need to reference them and can use the Module Functions below. FortranCInterface_GLOBAL_PREFIX Prefix for a global symbol without an underscore. FortranCInterface_GLOBAL_SUFFIX Suffix for a global symbol without an underscore. FortranCInterface_GLOBAL_CASE The case for a global symbol without an underscore, either UPPER or LOWER. FortranCInterface_GLOBAL__PREFIX Prefix for a global symbol with an underscore. FortranCInterface_GLOBAL__SUFFIX Suffix for a global symbol with an underscore. FortranCInterface_GLOBAL__CASE The case for a global symbol with an underscore, either UPPER or LOWER. FortranCInterface_MODULE_PREFIX Prefix for a module symbol without an underscore. FortranCInterface_MODULE_MIDDLE Middle of a module symbol without an underscore that appears between the name of the module and the name of the symbol. FortranCInterface_MODULE_SUFFIX Suffix for a module symbol without an underscore. FortranCInterface_MODULE_CASE The case for a module symbol without an underscore, either UPPER or LOWER. FortranCInterface_MODULE__PREFIX Prefix for a module symbol with an underscore. FortranCInterface_MODULE__MIDDLE Middle of a module symbol with an underscore that appears between the name of the module and the name of the symbol. FortranCInterface_MODULE__SUFFIX Suffix for a module symbol with an underscore. FortranCInterface_MODULE__CASE The case for a module symbol with an underscore, either UPPER or LOWER. Module Functions FortranCInterface_HEADER The FortranCInterface_HEADER function is provided to generate a C header file containing macros to mangle symbol names: FortranCInterface_HEADER(<file> [MACRO_NAMESPACE <macro-ns>] [SYMBOL_NAMESPACE <ns>] [SYMBOLS [<module>:]<function> ...]) It generates in <file> definitions of the following macros: #define FortranCInterface_GLOBAL (name,NAME) ... #define FortranCInterface_GLOBAL_(name,NAME) ... #define FortranCInterface_MODULE (mod,name, MOD,NAME) ... #define FortranCInterface_MODULE_(mod,name, MOD,NAME) ... These macros mangle four categories of Fortran symbols, respectively: • Global symbols without ‘_’: call mysub() • Global symbols with ‘_’ : call my_sub() • Module symbols without ‘_’: use mymod; call mysub() • Module symbols with ‘_’ : use mymod; call my_sub() If mangling for a category is not known, its macro is left undefined. All macros require raw names in both lower case and upper case. The options are: MACRO_NAMESPACE Replace the default FortranCInterface_ prefix with a given namespace <macro-ns>. SYMBOLS List symbols to mangle automatically with C preprocessor definitions: <function> ==> #define <ns><function> ... <module>:<function> ==> #define <ns><module>_<function> ... If the mangling for some symbol is not known then no preprocessor definition is created, and a warning is displayed. SYMBOL_NAMESPACE Prefix all preprocessor definitions generated by the SYMBOLS option with a given namespace <ns>. FortranCInterface_VERIFY The FortranCInterface_VERIFY function is provided to verify that the Fortran and C/C++ compilers work together: FortranCInterface_VERIFY([CXX] [QUIET]) It tests whether a simple test executable using Fortran and C (and C++ when the CXX option is given) compiles and links successfully. The result is stored in the cache entry FortranCInterface_VERIFIED_C (or FortranCInterface_VERIFIED_CXX if CXX is given) as a boolean. If the check fails and QUIET is not given the function terminates with a fatal error message describing the problem. The purpose of this check is to stop a build early for incompatible compiler combinations. The test is built in the Release configuration. Example Usage include(FortranCInterface) FortranCInterface_HEADER(FC.h MACRO_NAMESPACE FC_) This creates a “FC.h” header that defines mangling macros FC_GLOBAL(), FC_GLOBAL_(), FC_MODULE(), and FC_MODULE_(). include(FortranCInterface) FortranCInterface_HEADER(FCMangle.h MACRO_NAMESPACE FC_ SYMBOL_NAMESPACE FC_ SYMBOLS mysub mymod:my_sub) This creates a “FCMangle.h” header that defines the same FC_*() mangling macros as the previous example plus preprocessor symbols FC_mysub and FC_mymod_my_sub. Additional Manglings FortranCInterface is aware of possible GLOBAL and MODULE manglings for many Fortran compilers, but it also provides an interface to specify new possible manglings. Set the variables: FortranCInterface_GLOBAL_SYMBOLS FortranCInterface_MODULE_SYMBOLS before including FortranCInterface to specify manglings of the symbols MySub, My_Sub, MyModule:MySub, and My_Module:My_Sub. For example, the code: set(FortranCInterface_GLOBAL_SYMBOLS mysub_ my_sub__ MYSUB_) # ^^^^^ ^^^^^^ ^^^^^ set(FortranCInterface_MODULE_SYMBOLS __mymodule_MOD_mysub __my_module_MOD_my_sub) # ^^^^^^^^ ^^^^^ ^^^^^^^^^ ^^^^^^ include(FortranCInterface) tells FortranCInterface to try given GLOBAL and MODULE manglings. (The carets point at raw symbol names for clarity in this example but are not needed.) GenerateExportHeader Function for generation of export macros for libraries This module provides the function GENERATE_EXPORT_HEADER(). The GENERATE_EXPORT_HEADER function can be used to generate a file suitable for preprocessor inclusion which contains EXPORT macros to be used in library classes: GENERATE_EXPORT_HEADER( LIBRARY_TARGET [BASE_NAME <base_name>] [EXPORT_MACRO_NAME <export_macro_name>] [EXPORT_FILE_NAME <export_file_name>] [DEPRECATED_MACRO_NAME <deprecated_macro_name>] [NO_EXPORT_MACRO_NAME <no_export_macro_name>] [INCLUDE_GUARD_NAME <include_guard_name>] [STATIC_DEFINE <static_define>] [NO_DEPRECATED_MACRO_NAME <no_deprecated_macro_name>] [DEFINE_NO_DEPRECATED] [PREFIX_NAME <prefix_name>] [CUSTOM_CONTENT_FROM_VARIABLE <variable>] ) The target properties CXX_VISIBILITY_PRESET and VISIBILITY_INLINES_HIDDEN can be used to add the appropriate compile flags for targets. See the documentation of those target properties, and the convenience variables CMAKE_CXX_VISIBILITY_PRESET and CMAKE_VISIBILITY_INLINES_HIDDEN. By default GENERATE_EXPORT_HEADER() generates macro names in a file name determined by the name of the library. This means that in the simplest case, users of GenerateExportHeader will be equivalent to: set(CMAKE_CXX_VISIBILITY_PRESET hidden) set(CMAKE_VISIBILITY_INLINES_HIDDEN 1) add_library(somelib someclass.cpp) generate_export_header(somelib) install(TARGETS somelib DESTINATION ${LIBRARY_INSTALL_DIR}) install(FILES someclass.h ${PROJECT_BINARY_DIR}/somelib_export.h DESTINATION ${INCLUDE_INSTALL_DIR} ) And in the ABI header files: #include somelib_export.h class SOMELIB_EXPORT SomeClass { ... }; The CMake fragment will generate a file in the ${CMAKE_CURRENT_BINARY_DIR} called somelib_export.h containing the macros SOMELIB_EXPORT, SOMELIB_NO_EXPORT, SOMELIB_DEPRECATED, SOMELIB_DEPRECATED_EXPORT and SOMELIB_DEPRECATED_NO_EXPORT. They will be followed by content taken from the variable specified by the CUSTOM_CONTENT_FROM_VARIABLE option, if any. The resulting file should be installed with other headers in the li‐ brary. The BASE_NAME argument can be used to override the file name and the names used for the macros: add_library(somelib someclass.cpp) generate_export_header(somelib BASE_NAME other_name ) Generates a file called other_name_export.h containing the macros OTHER_NAME_EXPORT, OTHER_NAME_NO_EXPORT and OTHER_NAME_DEPRECATED etc. The BASE_NAME may be overridden by specifying other options in the function. For example: add_library(somelib someclass.cpp) generate_export_header(somelib EXPORT_MACRO_NAME OTHER_NAME_EXPORT ) creates the macro OTHER_NAME_EXPORT instead of SOMELIB_EXPORT, but other macros and the generated file name is as default: add_library(somelib someclass.cpp) generate_export_header(somelib DEPRECATED_MACRO_NAME KDE_DEPRECATED ) creates the macro KDE_DEPRECATED instead of SOMELIB_DEPRECATED. If LIBRARY_TARGET is a static library, macros are defined without values. If the same sources are used to create both a shared and a static library, the uppercased symbol ${BASE_NAME}_STATIC_DEFINE should be used when building the static library: add_library(shared_variant SHARED ${lib_SRCS}) add_library(static_variant ${lib_SRCS}) generate_export_header(shared_variant BASE_NAME libshared_and_static) set_target_properties(static_variant PROPERTIES COMPILE_FLAGS -DLIBSHARED_AND_STATIC_STATIC_DEFINE) This will cause the export macros to expand to nothing when building the static library. If DEFINE_NO_DEPRECATED is specified, then a macro ${BASE_NAME}_NO_DEPRECATED will be defined This macro can be used to remove deprecated code from preprocessor output: option(EXCLUDE_DEPRECATED Exclude deprecated parts of the library FALSE) if (EXCLUDE_DEPRECATED) set(NO_BUILD_DEPRECATED DEFINE_NO_DEPRECATED) endif() generate_export_header(somelib ${NO_BUILD_DEPRECATED}) And then in somelib: class SOMELIB_EXPORT SomeClass { public: #ifndef SOMELIB_NO_DEPRECATED SOMELIB_DEPRECATED void oldMethod(); #endif }; #ifndef SOMELIB_NO_DEPRECATED void SomeClass::oldMethod() { } #endif If PREFIX_NAME is specified, the argument will be used as a prefix to all generated macros. For example: generate_export_header(somelib PREFIX_NAME VTK_) Generates the macros VTK_SOMELIB_EXPORT etc. ADD_COMPILER_EXPORT_FLAGS( [<output_variable>] ) The ADD_COMPILER_EXPORT_FLAGS function adds -fvisibility=hidden to CMAKE_CXX_FLAGS if supported, and is a no-op on Windows which does not need ex‐ tra compiler flags for exporting support. You may optionally pass a single argument to ADD_COMPILER_EXPORT_FLAGS that will be populated with the CXX_FLAGS required to enable visibility support for the compiler/architecture in use. This function is deprecated. Set the target properties CXX_VISIBILITY_PRESET and VISIBILITY_INLINES_HIDDEN instead. GetPrerequisites Deprecated since version 3.16: Use file(GET_RUNTIME_DEPENDENCIES) instead. Functions to analyze and list executable file prerequisites. This module provides functions to list the .dll, .dylib or .so files that an executable or shared library file depends on. (Its prerequisites.) It uses various tools to obtain the list of required shared library files: dumpbin (Windows) objdump (MinGW on Windows) ldd (Linux/Unix) otool (Mac OSX) The following functions are provided by this module: get_prerequisites list_prerequisites list_prerequisites_by_glob gp_append_unique is_file_executable gp_item_default_embedded_path (projects can override with gp_item_default_embedded_path_override) gp_resolve_item (projects can override with gp_resolve_item_override) gp_resolved_file_type (projects can override with gp_resolved_file_type_override) gp_file_type Requires CMake 2.6 or greater because it uses function, break, return and PARENT_SCOPE. GET_PREREQUISITES(<target> <prerequisites_var> <exclude_system> <recurse> <exepath> <dirs> [<rpaths>]) Get the list of shared library files required by <target>. The list in the variable named <prerequisites_var> should be empty on first entry to this function. On exit, <prerequisites_var> will contain the list of required shared library files. <target> is the full path to an executable file. <prerequisites_var> is the name of a CMake variable to contain the results. <exclude_system> must be 0 or 1 indicating whether to include or exclude “system” prerequisites. If <recurse> is set to 1 all prerequisites will be found recur‐ sively, if set to 0 only direct prerequisites are listed. <exepath> is the path to the top level executable used for @executable_path replacment on the Mac. <dirs> is a list of paths where libraries might be found: these paths are searched first when a target without any path info is given. Then standard system locations are also searched: PATH, Framework locations, /usr/lib… The variable GET_PREREQUISITES_VERBOSE can be set to true to enable verbose output. LIST_PREREQUISITES(<target> [<recurse> [<exclude_system> [<verbose>]]]) Print a message listing the prerequisites of <target>. <target> is the name of a shared library or executable target or the full path to a shared library or executable file. If <recurse> is set to 1 all prerequisites will be found recursively, if set to 0 only direct prerequisites are listed. <exclude_system> must be 0 or 1 indicating whether to include or exclude “system” prerequisites. With <verbose> set to 0 only the full path names of the prerequisites are printed, set to 1 extra informatin will be displayed. LIST_PREREQUISITES_BY_GLOB(<glob_arg> <glob_exp>) Print the prerequisites of shared library and executable files matching a globbing pattern. <glob_arg> is GLOB or GLOB_RECURSE and <glob_exp> is a globbing expression used with “file(GLOB” or “file(GLOB_RECURSE” to retrieve a list of matching files. If a matching file is executable, its prerequisites are listed. Any additional (optional) arguments provided are passed along as the optional arguments to the list_prerequisites calls. GP_APPEND_UNIQUE(<list_var> <value>) Append <value> to the list variable <list_var> only if the value is not already in the list. IS_FILE_EXECUTABLE(<file> <result_var>) Return 1 in <result_var> if <file> is a binary executable, 0 otherwise. GP_ITEM_DEFAULT_EMBEDDED_PATH(<item> <default_embedded_path_var>) Return the path that others should refer to the item by when the item is embedded inside a bundle. Override on a per-project basis by providing a project-specific gp_item_default_embedded_path_override function. GP_RESOLVE_ITEM(<context> <item> <exepath> <dirs> <resolved_item_var> [<rpaths>]) Resolve an item into an existing full path file. Override on a per-project basis by providing a project-specific gp_resolve_item_override function. GP_RESOLVED_FILE_TYPE(<original_file> <file> <exepath> <dirs> <type_var> [<rpaths>]) Return the type of <file> with respect to <original_file>. String describing type of prerequisite is returned in variable named <type_var>. Use <exepath> and <dirs> if necessary to resolve non-absolute <file> values – but only for non-embedded items. Possible types are: system local embedded other Override on a per-project basis by providing a project-specific gp_resolved_file_type_override function. GP_FILE_TYPE(<original_file> <file> <type_var>) Return the type of <file> with respect to <original_file>. String describing type of prerequisite is returned in variable named <type_var>. Possible types are: system local embedded other GNUInstallDirs Define GNU standard installation directories Provides install directory variables as defined by the GNU Coding Standards. Result Variables Inclusion of this module defines the following variables: CMAKE_INSTALL_<dir> Destination for files of a given type. This value may be passed to the DESTINATION options of install() commands for the corresponding file type. CMAKE_INSTALL_FULL_<dir> The absolute path generated from the corresponding CMAKE_INSTALL_<dir> value. If the value is not already an absolute path, an absolute path is constructed typically by prepending the value of the CMAKE_INSTALL_PREFIX variable. However, there are some special cases as documented be‐ low. where <dir> is one of: BINDIR user executables (bin) SBINDIR system admin executables (sbin) LIBEXECDIR program executables (libexec) SYSCONFDIR read-only single-machine data (etc) SHAREDSTATEDIR modifiable architecture-independent data (com) LOCALSTATEDIR modifiable single-machine data (var) RUNSTATEDIR run-time variable data (LOCALSTATEDIR/run) LIBDIR object code libraries (lib or lib64 or lib/<multiarch-tuple> on Debian) INCLUDEDIR C header files (include) OLDINCLUDEDIR C header files for non-gcc (/usr/include) DATAROOTDIR read-only architecture-independent data root (share) DATADIR read-only architecture-independent data (DATAROOTDIR) INFODIR info documentation (DATAROOTDIR/info) LOCALEDIR locale-dependent data (DATAROOTDIR/locale) MANDIR man documentation (DATAROOTDIR/man) DOCDIR documentation root (DATAROOTDIR/doc/PROJECT_NAME) If the includer does not define a value the above-shown default will be used and the value will appear in the cache for editing by the user. Special Cases The following values of CMAKE_INSTALL_PREFIX are special: / For <dir> other than the SYSCONFDIR, LOCALSTATEDIR and RUNSTATEDIR, the value of CMAKE_INSTALL_<dir> is prefixed with usr/ if it is not user-specified as an absolute path. For example, the INCLUDEDIR value include becomes usr/include. This is required by the GNU Coding Stan‐ dards, which state: When building the complete GNU system, the prefix will be empty and /usr will be a symbolic link to /. /usr For <dir> equal to SYSCONFDIR, LOCALSTATEDIR or RUNSTATEDIR, the CMAKE_INSTALL_FULL_<dir> is computed by prepending just / to the value of CMAKE_INSTALL_<dir> if it is not user-specified as an absolute path. For example, the SYSCONFDIR value etc becomes /etc. This is required by the GNU Coding Standards. /opt/... For <dir> equal to SYSCONFDIR, LOCALSTATEDIR or RUNSTATEDIR, the CMAKE_INSTALL_FULL_<dir> is computed by appending the prefix to the value of CMAKE_INSTALL_<dir> if it is not user-specified as an absolute path. For example, the SYSCONFDIR value etc becomes /etc/opt/.... This is de‐ fined by the Filesystem Hierarchy Standard. Macros GNUInstallDirs_get_absolute_install_dir GNUInstallDirs_get_absolute_install_dir(absvar var) Set the given variable absvar to the absolute path contained within the variable var. This is to allow the computation of an absolute path, accounting for all the special cases documented above. While this macro is used to compute the various CMAKE_INSTALL_FULL_<dir> variables, it is exposed publicly to allow users who create additional path variables to also compute absolute paths where necessary, using the same logic. GoogleTest This module defines functions to help use the Google Test infrastructure. Two mechanisms for adding tests are provided. gtest_add_tests() has been around for some time, originally via find_package(GTest). gtest_discover_tests() was introduced in CMake 3.10. The (older) gtest_add_tests() scans source files to identify tests. This is usually effective, with some caveats, including in cross-compiling environments, and makes setting additional properties on tests more convenient. However, its handling of parameterized tests is less comprehen‐ sive, and it requires re-running CMake to detect changes to the list of tests. The (newer) gtest_discover_tests() discovers tests by asking the compiled test executable to enumerate its tests. This is more robust and pro‐ vides better handling of parameterized tests, and does not require CMake to be re-run when tests change. However, it may not work in a cross-com‐ piling environment, and setting test properties is less convenient. More details can be found in the documentation of the respective functions. Both commands are intended to replace use of add_test() to register tests, and will create a separate CTest test for each Google Test test case. Note that this is in some cases less efficient, as common set-up and tear-down logic cannot be shared by multiple test cases executing in the same instance. However, it provides more fine-grained pass/fail information to CTest, which is usually considered as more beneficial. By default, the CTest test name is the same as the Google Test name (i.e. suite.testcase); see also TEST_PREFIX and TEST_SUFFIX. gtest_add_tests Automatically add tests with CTest by scanning source code for Google Test macros: gtest_add_tests(TARGET target [SOURCES src1...] [EXTRA_ARGS arg1...] [WORKING_DIRECTORY dir] [TEST_PREFIX prefix] [TEST_SUFFIX suffix] [SKIP_DEPENDENCY] [TEST_LIST outVar] ) gtest_add_tests attempts to identify tests by scanning source files. Although this is generally effective, it uses only a basic regular expression match, which can be defeated by atypical test declarations, and is unable to fully “split” parameterized tests. Additionally, it requires that CMake be re-run to discover any newly added, removed or renamed tests (by default, this means that CMake is re-run when any test source file is changed, but see SKIP_DEPENDENCY). However, it has the advantage of declaring tests at CMake time, which somewhat simplifies setting additional properties on tests, and always works in a cross-compiling environment. The options are: TARGET target Specifies the Google Test executable, which must be a known CMake executable target. CMake will substitute the location of the built executable when running the test. SOURCES src1... When provided, only the listed files will be scanned for test cases. If this option is not given, the SOURCES property of the spec‐ ified target will be used to obtain the list of sources. EXTRA_ARGS arg1... Any extra arguments to pass on the command line to each test case. WORKING_DIRECTORY dir Specifies the directory in which to run the discovered test cases. If this option is not provided, the current binary directory is used. TEST_PREFIX prefix Specifies a prefix to be prepended to the name of each discovered test case. This can be useful when the same source files are be‐ ing used in multiple calls to gtest_add_test() but with different EXTRA_ARGS. TEST_SUFFIX suffix Similar to TEST_PREFIX except the suffix is appended to the name of every discovered test case. Both TEST_PREFIX and TEST_SUFFIX may be specified. SKIP_DEPENDENCY Normally, the function creates a dependency which will cause CMake to be re-run if any of the sources being scanned are changed. This is to ensure that the list of discovered tests is updated. If this behavior is not desired (as may be the case while actually writing the test cases), this option can be used to prevent the dependency from being added. TEST_LIST outVar The variable named by outVar will be populated in the calling scope with the list of discovered test cases. This allows the caller to do things like manipulate test properties of the discovered tests. include(GoogleTest) add_executable(FooTest FooUnitTest.cxx) gtest_add_tests(TARGET FooTest TEST_SUFFIX .noArgs TEST_LIST noArgsTests ) gtest_add_tests(TARGET FooTest EXTRA_ARGS --someArg someValue TEST_SUFFIX .withArgs TEST_LIST withArgsTests ) set_tests_properties(${noArgsTests} PROPERTIES TIMEOUT 10) set_tests_properties(${withArgsTests} PROPERTIES TIMEOUT 20) For backward compatibility, the following form is also supported: gtest_add_tests(exe args files...) exe The path to the test executable or the name of a CMake target. args A ;-list of extra arguments to be passed to executable. The entire list must be passed as a single argument. Enclose it in quotes, or pass  for no arguments. files... A list of source files to search for tests and test fixtures. Alternatively, use AUTO to specify that exe is the name of a CMake executable target whose sources should be scanned. include(GoogleTest) set(FooTestArgs --foo 1 --bar 2) add_executable(FooTest FooUnitTest.cxx) gtest_add_tests(FooTest ${FooTestArgs} AUTO) gtest_discover_tests Automatically add tests with CTest by querying the compiled test executable for available tests: gtest_discover_tests(target [EXTRA_ARGS arg1...] [WORKING_DIRECTORY dir] [TEST_PREFIX prefix] [TEST_SUFFIX suffix] [NO_PRETTY_TYPES] [NO_PRETTY_VALUES] [PROPERTIES name1 value1...] [TEST_LIST var] [DISCOVERY_TIMEOUT seconds] ) gtest_discover_tests sets up a post-build command on the test executable that generates the list of tests by parsing the output from run‐ ning the test with the --gtest_list_tests argument. Compared to the source parsing approach of gtest_add_tests(), this ensures that the full list of tests, including instantiations of parameterized tests, is obtained. Since test discovery occurs at build time, it is not necessary to re-run CMake when the list of tests changes. However, it requires that CROSSCOMPILING_EMULATOR is properly set in order to function in a cross-compiling environment. Additionally, setting properties on tests is somewhat less convenient, since the tests are not available at CMake time. Additional test properties may be assigned to the set of tests as a whole using the PROPERTIES option. If more fine-grained test control is needed, custom content may be provided through an external CTest script using the TEST_INCLUDE_FILES directory property. The set of discovered tests is made accessible to such a script via the <target>_TESTS variable. The options are: target Specifies the Google Test executable, which must be a known CMake executable target. CMake will substitute the location of the built executable when running the test. EXTRA_ARGS arg1... Any extra arguments to pass on the command line to each test case. WORKING_DIRECTORY dir Specifies the directory in which to run the discovered test cases. If this option is not provided, the current binary directory is used. TEST_PREFIX prefix Specifies a prefix to be prepended to the name of each discovered test case. This can be useful when the same test executable is being used in multiple calls to gtest_discover_tests() but with different EXTRA_ARGS. TEST_SUFFIX suffix Similar to TEST_PREFIX except the suffix is appended to the name of every discovered test case. Both TEST_PREFIX and TEST_SUFFIX may be specified. NO_PRETTY_TYPES By default, the type index of type-parameterized tests is replaced by the actual type name in the CTest test name. If this behavior is undesirable (e.g. because the type names are unwieldy), this option will suppress this behavior. NO_PRETTY_VALUES By default, the value index of value-parameterized tests is replaced by the actual value in the CTest test name. If this behavior is undesirable (e.g. because the value strings are unwieldy), this option will suppress this behavior. PROPERTIES name1 value1... Specifies additional properties to be set on all tests discovered by this invocation of gtest_discover_tests. TEST_LIST var Make the list of tests available in the variable var, rather than the default <target>_TESTS. This can be useful when the same test executable is being used in multiple calls to gtest_discover_tests(). Note that this variable is only available in CTest. DISCOVERY_TIMEOUT num Specifies how long (in seconds) CMake will wait for the test to enumerate available tests. If the test takes longer than this, dis‐ covery (and your build) will fail. Most test executables will enumerate their tests very quickly, but under some exceptional cir‐ cumstances, a test may require a longer timeout. The default is 5. See also the TIMEOUT option of execute_process(). NOTE: In CMake versions 3.10.1 and 3.10.2, this option was called TIMEOUT. This clashed with the TIMEOUT test property, which is one of the common properties that would be set with the PROPERTIES keyword, usually leading to legal but unintended behavior. The keyword was changed to DISCOVERY_TIMEOUT in CMake 3.10.3 to address this problem. The ambiguous behavior of the TIMEOUT keyword in 3.10.1 and 3.10.2 has not been preserved. InstallRequiredSystemLibraries Include this module to search for compiler-provided system runtime libraries and add install rules for them. Some optional variables may be set prior to including the module to adjust behavior: CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS Specify additional runtime libraries that may not be detected. After inclusion any detected libraries will be appended to this. CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_SKIP Set to TRUE to skip calling the install(PROGRAMS) command to allow the includer to specify its own install rule, using the value of CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS to get the list of libraries. CMAKE_INSTALL_DEBUG_LIBRARIES Set to TRUE to install the debug runtime libraries when available with MSVC tools. CMAKE_INSTALL_DEBUG_LIBRARIES_ONLY Set to TRUE to install only the debug runtime libraries with MSVC tools even if the release runtime libraries are also available. CMAKE_INSTALL_UCRT_LIBRARIES Set to TRUE to install the Windows Universal CRT libraries for app-local deployment (e.g. to Windows XP). This is meaningful only with MSVC from Visual Studio 2015 or higher. One may set a CMAKE_WINDOWS_KITS_10_DIR environment variable to an absolute path to tell CMake to look for Windows 10 SDKs in a custom lo‐ cation. The specified directory is expected to contain Redist/ucrt/DLLs/* directories. CMAKE_INSTALL_MFC_LIBRARIES Set to TRUE to install the MSVC MFC runtime libraries. CMAKE_INSTALL_OPENMP_LIBRARIES Set to TRUE to install the MSVC OpenMP runtime libraries CMAKE_INSTALL_SYSTEM_RUNTIME_DESTINATION Specify the install(PROGRAMS) command DESTINATION option. If not specified, the default is bin on Windows and lib elsewhere. CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_NO_WARNINGS Set to TRUE to disable warnings about required library files that do not exist. (For example, Visual Studio Express editions may not pro‐ vide the redistributable files.) CMAKE_INSTALL_SYSTEM_RUNTIME_COMPONENT Specify the install(PROGRAMS) command COMPONENT option. If not specified, no such option will be used. ProcessorCount ProcessorCount(var) Determine the number of processors/cores and save value in ${var} Sets the variable named ${var} to the number of physical cores available on the machine if the information can be determined. Otherwise it is set to 0. Currently this functionality is implemented for AIX, cygwin, FreeBSD, HPUX, Linux, macOS, QNX, Sun and Windows. This function is guaranteed to return a positive integer (>=1) if it succeeds. It returns 0 if there’s a problem determining the processor count. Example use, in a ctest -S dashboard script: include(ProcessorCount) ProcessorCount(N) if(NOT N EQUAL 0) set(CTEST_BUILD_FLAGS -j${N}) set(ctest_test_args ${ctest_test_args} PARALLEL_LEVEL ${N}) endif() This function is intended to offer an approximation of the value of the number of compute cores available on the current machine, such that you may use that value for parallel building and parallel testing. It is meant to help utilize as much of the machine as seems reasonable. Of course, knowledge of what else might be running on the machine simultaneously should be used when deciding whether to request a machine’s full ca‐ pacity all for yourself. SelectLibraryConfigurations select_library_configurations(basename) This macro takes a library base name as an argument, and will choose good values for the variables basename_LIBRARY basename_LIBRARIES basename_LIBRARY_DEBUG basename_LIBRARY_RELEASE depending on what has been found and set. If only basename_LIBRARY_RELEASE is defined, basename_LIBRARY will be set to the release value, and basename_LIBRARY_DEBUG will be set to base‐ name_LIBRARY_DEBUG-NOTFOUND. If only basename_LIBRARY_DEBUG is defined, then basename_LIBRARY will take the debug value, and basename_LIBRARY_RE‐ LEASE will be set to basename_LIBRARY_RELEASE-NOTFOUND. If the generator supports configuration types, then basename_LIBRARY and basename_LIBRARIES will be set with debug and optimized flags specifying the library to be used for the given configuration. If no build type has been set or the generator in use does not support configuration types, then basename_LIBRARY and basename_LIBRARIES will take only the release value, or the debug value if the release one is not set. SquishTestScript This script launches a GUI test using Squish. You should not call the script directly; instead, you should access it via the SQUISH_ADD_TEST macro that is defined in FindSquish.cmake. This script starts the Squish server, launches the test on the client, and finally stops the squish server. If any of these steps fail (including if the tests do not pass) then a fatal error is raised. TestBigEndian Define macro to determine endian type Check if the system is big endian or little endian TEST_BIG_ENDIAN(VARIABLE) VARIABLE - variable to store the result to TestForANSIForScope Check for ANSI for scope support Check if the compiler restricts the scope of variables declared in a for-init-statement to the loop body. CMAKE_NO_ANSI_FOR_SCOPE - holds result TestForANSIStreamHeaders Test for compiler support of ANSI stream headers iostream, etc. check if the compiler supports the standard ANSI iostream header (without the .h) CMAKE_NO_ANSI_STREAM_HEADERS - defined by the results TestForSSTREAM Test for compiler support of ANSI sstream header check if the compiler supports the standard ANSI sstream header CMAKE_NO_ANSI_STRING_STREAM - defined by the results TestForSTDNamespace Test for std:: namespace support check if the compiler supports std:: on stl classes CMAKE_NO_STD_NAMESPACE - defined by the results UseEcos This module defines variables and macros required to build eCos application. This file contains the following macros: ECOS_ADD_INCLUDE_DIRECTORIES() - add the eCos include dirs ECOS_ADD_EXECUTABLE(name source1 … sourceN ) - create an eCos executable ECOS_ADJUST_DIRECTORY(VAR source1 … sourceN ) - adjusts the path of the source files and puts the result into VAR Macros for selecting the toolchain: ECOS_USE_ARM_ELF_TOOLS() - enable the ARM ELF toolchain for the directory where it is called ECOS_USE_I386_ELF_TOOLS() - enable the i386 ELF toolchain for the directory where it is called ECOS_USE_PPC_EABI_TOOLS() - enable the PowerPC toolchain for the directory where it is called It contains the following variables: ECOS_DEFINITIONS ECOSCONFIG_EXECUTABLE ECOS_CONFIG_FILE - defaults to ecos.ecc, if your eCos configuration file has a different name, adjust this variable for internal use only: ECOS_ADD_TARGET_LIB UseJavaClassFilelist This script create a list of compiled Java class files to be added to a jar file. This avoids including cmake files which get created in the bi‐ nary directory. UseJava Use Module for Java This file provides functions for Java. It is assumed that FindJava has already been loaded. See FindJava for information on how to load Java into your CMake project. Creating And Installing JARs add_jar(<target_name> [SOURCES] <source1> [<source2>...] [<resource1>...] [INCLUDE_JARS <jar1> [<jar2>...]] [ENTRY_POINT <entry>] [VERSION <version>] [OUTPUT_NAME <name>] [OUTPUT_DIR <dir>] [GENERATE_NATIVE_HEADERS <target> [DESTINATION <dir>]] ) This command creates a <target_name>.jar. It compiles the given <source> files and adds the given <resource> files to the jar file. Source files can be java files or listing files (prefixed by @). If only resource files are given then just a jar file is created. The list of INCLUDE_JARS are added to the classpath when compiling the java sources and also to the dependencies of the target. INCLUDE_JARS also accepts other target names created by add_jar(). For backwards compatibility, jar files listed as sources are ignored (as they have been since the first version of this module). The default OUTPUT_DIR can also be changed by setting the variable CMAKE_JAVA_TARGET_OUTPUT_DIR. Optionally, using option GENERATE_NATIVE_HEADERS, native header files can be generated for methods declared as native. These files provide the connective glue that allow your Java and C code to interact. An INTERFACE target will be created for an easy usage of generated files. Sub-op‐ tion DESTINATION can be used to specify the output directory for generated header files. GENERATE_NATIVE_HEADERS option requires, at least, version 1.8 of the JDK. The add_jar() function sets the following target properties on <target_name>: INSTALL_FILES The files which should be installed. This is used by install_jar(). JNI_SYMLINK The JNI symlink which should be installed. This is used by install_jni_symlink(). JAR_FILE The location of the jar file so that you can include it. CLASSDIR The directory where the class files can be found. For example to use them with javah. install_jar(<target_name> <destination>) install_jar(<target_name> DESTINATION <destination> [COMPONENT <component>]) This command installs the <target_name> files to the given <destination>. It should be called in the same scope as add_jar() or it will fail. The install_jar() function sets the INSTALL_DESTINATION target property on jars so installed. This property holds the <destination> as described above, and is used by install_jar_exports(). You can get this information with get_property() and the INSTALL_DESTINATION property key. install_jni_symlink(<target_name> <destination>) install_jni_symlink(<target_name> DESTINATION <destination> [COMPONENT <component>]) This command installs the <target_name> JNI symlinks to the given <destination>. It should be called in the same scope as add_jar() or it will fail. install_jar_exports(TARGETS <jars>... [NAMESPACE <namespace>] FILE <filename> DESTINATION <destination> [COMPONENT <component>]) This command installs a target export file <filename> for the named jar targets to the given <destination> directory. Its function is similar to that of install(EXPORTS). export_jars(TARGETS <jars>... [NAMESPACE <namespace>] FILE <filename>) This command writes a target export file <filename> for the named <jars> targets. Its function is similar to that of export(). Examples To add compile flags to the target you can set these flags with the following variable: set(CMAKE_JAVA_COMPILE_FLAGS -nowarn) To add a path or a jar file to the class path you can do this with the CMAKE_JAVA_INCLUDE_PATH variable. set(CMAKE_JAVA_INCLUDE_PATH /usr/share/java/shibboleet.jar) To use a different output name for the target you can set it with: add_jar(foobar foobar.java OUTPUT_NAME shibboleet.jar) To use a different output directory than CMAKE_CURRENT_BINARY_DIR you can set it with: add_jar(foobar foobar.java OUTPUT_DIR ${PROJECT_BINARY_DIR}/bin) To define an entry point in your jar you can set it with the ENTRY_POINT named argument: add_jar(example ENTRY_POINT com/examples/MyProject/Main) To define a custom manifest for the jar, you can set it with the MANIFEST named argument: add_jar(example MANIFEST /path/to/manifest) To add a version to the target output name you can set it using the VERSION named argument to add_jar(). The following example will create a jar file with the name shibboleet-1.0.0.jar and will create a symlink shibboleet.jar pointing to the jar with the version information. add_jar(shibboleet shibbotleet.java VERSION 1.2.0) If the target is a JNI library, utilize the following commands to create a JNI symbolic link: set(CMAKE_JNI_TARGET TRUE) add_jar(shibboleet shibbotleet.java VERSION 1.2.0) install_jar(shibboleet ${LIB_INSTALL_DIR}/shibboleet) install_jni_symlink(shibboleet ${JAVA_LIB_INSTALL_DIR}) If a single target needs to produce more than one jar from its java source code, to prevent the accumulation of duplicate class files in subse‐ quent jars, set/reset CMAKE_JAR_CLASSES_PREFIX prior to calling the add_jar() function: set(CMAKE_JAR_CLASSES_PREFIX com/redhat/foo) add_jar(foo foo.java) set(CMAKE_JAR_CLASSES_PREFIX com/redhat/bar) add_jar(bar bar.java) For an optimum usage of option GENERATE_NATIVE_HEADERS, it is recommended to include module JNI before any call to add_jar(). The produced target for native headers can then be used to compile C/C++ sources with the target_link_libraries() command. find_package(JNI) add_jar(foo foo.java GENERATE_NATIVE_HEADERS foo-native) add_library(bar bar.cpp) target_link_libraries(bar PRIVATE foo-native) Finding JARs find_jar(<VAR> <name> | NAMES <name1> [<name2>...] [PATHS <path1> [<path2>... ENV <var>]] [VERSIONS <version1> [<version2>]] [DOC cache documentation string] ) This command is used to find a full path to the named jar. A cache entry named by <VAR> is created to store the result of this command. If the full path to a jar is found the result is stored in the variable and the search will not repeated unless the variable is cleared. If nothing is found, the result will be <VAR>-NOTFOUND, and the search will be attempted again next time find_jar() is invoked with the same variable. The name of the full path to a file that is searched for is specified by the names listed after NAMES argument. Additional search locations can be speci‐ fied after the PATHS argument. If you require special a version of a jar file you can specify it with the VERSIONS argument. The argument after DOC will be used for the documentation string in the cache. Javadoc The create_javadoc() command can be used to create java documentation based on files or packages. For more details please read the javadoc man‐ page. There are two main signatures for create_javadoc(). The first signature works with package names on a path with source files. create_javadoc(<VAR> PACKAGES <pkg1> [<pkg2>...] [SOURCEPATH <sourcepath>] [CLASSPATH <classpath>] [INSTALLPATH <install path>] [DOCTITLE the documentation title] [WINDOWTITLE the title of the document] [AUTHOR TRUE|FALSE] [USE TRUE|FALSE] [VERSION TRUE|FALSE] ) For example: create_javadoc(my_example_doc PACKAGES com.example.foo com.example.bar SOURCEPATH ${CMAKE_CURRENT_SOURCE_DIR} CLASSPATH ${CMAKE_JAVA_INCLUDE_PATH} WINDOWTITLE My example DOCTITLE <h1>My example</h1> AUTHOR TRUE USE TRUE VERSION TRUE ) The second signature for create_javadoc() works on a given list of files. create_javadoc(<VAR> FILES <file1> [<file2>...] [CLASSPATH <classpath>] [INSTALLPATH <install path>] [DOCTITLE the documentation title] [WINDOWTITLE the title of the document] [AUTHOR TRUE|FALSE] [USE TRUE|FALSE] [VERSION TRUE|FALSE] ) For example: create_javadoc(my_example_doc FILES ${example_SRCS} CLASSPATH ${CMAKE_JAVA_INCLUDE_PATH} WINDOWTITLE My example DOCTITLE <h1>My example</h1> AUTHOR TRUE USE TRUE VERSION TRUE ) Both signatures share most of the options. These options are the same as what you can find in the javadoc manpage. Please look at the manpage for CLASSPATH, DOCTITLE, WINDOWTITLE, AUTHOR, USE and VERSION. If you don’t set the INSTALLPATH, then by default the documentation will be installed to : ${CMAKE_INSTALL_PREFIX}/share/javadoc/<VAR> Header Generation create_javah(TARGET <target> | GENERATED_FILES <VAR> CLASSES <class>... [CLASSPATH <classpath>...] [DEPENDS <depend>...] [OUTPUT_NAME <path>|OUTPUT_DIR <path>] ) Create C header files from java classes. These files provide the connective glue that allow your Java and C code to interact. Deprecated since version 3.11. NOTE: This command will no longer be supported starting with version 10 of the JDK due to the suppression of javah tool. The add_jar(GENERATE_NA‐ TIVE_HEADERS) command should be used instead. There are two main signatures for create_javah(). The first signature returns generated files through variable specified by the GENERATED_FILES option. For example: create_javah(GENERATED_FILES files_headers CLASSES org.cmake.HelloWorld CLASSPATH hello.jar ) The second signature for create_javah() creates a target which encapsulates header files generation. E.g. create_javah(TARGET target_headers CLASSES org.cmake.HelloWorld CLASSPATH hello.jar ) Both signatures share same options. CLASSES <class>... Specifies Java classes used to generate headers. CLASSPATH <classpath>... Specifies various paths to look up classes. Here .class files, jar files or targets created by command add_jar can be used. DEPENDS <depend>... Targets on which the javah target depends. OUTPUT_NAME <path> Concatenates the resulting header files for all the classes listed by option CLASSES into <path>. Same behavior as option -o of javah tool. OUTPUT_DIR <path> Sets the directory where the header files will be generated. Same behavior as option -d of javah tool. If not specified, CMAKE_CUR‐ RENT_BINARY_DIR is used as the output directory. UseJavaSymlinks Helper script for UseJava.cmake UseSWIG This file provides support for SWIG. It is assumed that FindSWIG module has already been loaded. Defines the following command for use with SWIG: swig_add_library Define swig module with given name and specified language: swig_add_library(<name> [TYPE <SHARED|MODULE|STATIC|USE_BUILD_SHARED_LIBS>] LANGUAGE <language> [NO_PROXY] [OUTPUT_DIR <directory>] [OUTFILE_DIR <directory>] SOURCES <file>... ) Targets created with the swig_add_library command have the same capabilities as targets created with the add_library() command, so those targets can be used with any command expecting a target (e.g. target_link_libraries()). NOTE: This command creates a target with the specified <name> when policy CMP0078 is set to NEW. Otherwise, the legacy behavior will choose a different target name and store it in the SWIG_MODULE_<name>_REAL_NAME variable. NOTE: For multi-config generators, this module does not support configuration-specific files generated by SWIG. All build configurations must result in the same generated source file. TYPE SHARED, MODULE and STATIC have the same semantic as for the add_library() command. If USE_BUILD_SHARED_LIBS is specified, the li‐ brary type will be STATIC or SHARED based on whether the current value of the BUILD_SHARED_LIBS variable is ON. If no type is speci‐ fied, MODULE will be used. LANGUAGE Specify the target language. NO_PROXY Prevent the generation of the wrapper layer (swig -noproxy option). OUTPUT_DIR Specify where to write the language specific files (swig -outdir option). If not given, the CMAKE_SWIG_OUTDIR variable will be used. If neither is specified, the default depends on the value of the UseSWIG_MODULE_VERSION variable as follows: • If UseSWIG_MODULE_VERSION is 1 or is undefined, output is written to the CMAKE_CURRENT_BINARY_DIR directory. • If UseSWIG_MODULE_VERSION is 2, a dedicated directory will be used. The path of this directory can be retrieved from the SWIG_SUPPORT_FILES_DIRECTORY target property. OUTFILE_DIR Specify an output directory name where the generated source file will be placed (swig -o option). If not specified, the SWIG_OUT‐ FILE_DIR variable will be used. If neither is specified, OUTPUT_DIR or CMAKE_SWIG_OUTDIR is used instead. SOURCES List of sources for the library. Files with extension .i will be identified as sources for the SWIG tool. Other files will be han‐ dled in the standard way. This behavior can be overriden by specifying the variable SWIG_SOURCE_FILE_EXTENSIONS. NOTE: If UseSWIG_MODULE_VERSION is set to 2, it is strongly recommended to use a dedicated directory unique to the target when either the OUT‐ PUT_DIR option or the CMAKE_SWIG_OUTDIR variable are specified. The output directory contents are erased as part of the target build, so to prevent interference between targets or losing other important files, each target should have its own dedicated output directory. swig_link_libraries Link libraries to swig module: swig_link_libraries(<name> <item>...) This command has same capabilities as target_link_libraries() command. NOTE: If variable UseSWIG_TARGET_NAME_PREFERENCE is set to STANDARD, this command is deprecated and target_link_libraries() command must be used instead. Source file properties on module files must be set before the invocation of the swig_add_library command to specify special behavior of SWIG and ensure generated files will receive the required settings. CPLUSPLUS Call SWIG in c++ mode. For example: set_property(SOURCE mymod.i PROPERTY CPLUSPLUS ON) swig_add_library(mymod LANGUAGE python SOURCES mymod.i) DOXYGEN_INPUT Projects should not set this variable. It will be populated with the set of files and directories passed to doxygen_add_docs(), thereby providing consistent behavior with the other built-in commands like add_executable(), add_library() and add_custom_target(). If a variable named DOXYGEN_INPUT is set by the project, it will be ignored and a warning will be issued. DOXYGEN_RECURSIVE Set to YES by this module. DOXYGEN_EXCLUDE_PATTERNS If the set of inputs includes directories, this variable will specify patterns used to exclude files from them. The following pat‐ terns are added by doxygen_add_docs() to ensure CMake-specific files and directories are not included in the input. If the project sets DOXYGEN_EXCLUDE_PATTERNS, those contents are merged with these additional patterns rather than replacing them: */.git/* */.svn/* */.hg/* */CMakeFiles/* */_CPack_Packages/* DartConfiguration.tcl CMakeLists.txt CMakeCache.txt DOXYGEN_OUTPUT_DIRECTORY Set to CMAKE_CURRENT_BINARY_DIR by this module. Note that if the project provides its own value for this and it is a relative path, it will be converted to an absolute path relative to the current binary directory. This is necessary because doxygen will normally be run from a directory within the source tree so that relative source paths work as expected. If this directory does not exist, it will be recursively created prior to executing the doxygen commands. To change any of these defaults or override any other Doxygen config option, set relevant variables before calling doxygen_add_docs(). For exam‐ ple: set(DOXYGEN_GENERATE_HTML NO) set(DOXYGEN_GENERATE_MAN YES) doxygen_add_docs( doxygen ${PROJECT_SOURCE_DIR} COMMENT Generate man pages ) A number of Doxygen config options accept lists of values, but Doxygen requires them to be separated by whitespace. CMake variables hold lists as a string with items separated by semi-colons, so a conversion needs to be performed. The doxygen_add_docs() command specifically checks the fol‐ lowing Doxygen config options and will convert their associated CMake variable’s contents into the required form if set. ABBREVIATE_BRIEF ALIASES CITE_BIB_FILES DIAFILE_DIRS DOTFILE_DIRS DOT_FONTPATH ENABLED_SECTIONS EXAMPLE_PATH EXAMPLE_PATTERNS EXCLUDE EXCLUDE_PATTERNS EXCLUDE_SYMBOLS EXPAND_AS_DEFINED EXTENSION_MAPPING EXTRA_PACKAGES EXTRA_SEARCH_MAPPINGS FILE_PATTERNS FILTER_PATTERNS FILTER_SOURCE_PATTERNS HTML_EXTRA_FILES HTML_EXTRA_STYLESHEET IGNORE_PREFIX IMAGE_PATH INCLUDE_FILE_PATTERNS INCLUDE_PATH INPUT LATEX_EXTRA_FILES LATEX_EXTRA_STYLESHEET MATHJAX_EXTENSIONS MSCFILE_DIRS PLANTUML_INCLUDE_PATH PREDEFINED QHP_CUST_FILTER_ATTRS QHP_SECT_FILTER_ATTRS STRIP_FROM_INC_PATH STRIP_FROM_PATH TAGFILES TCL_SUBST The following single value Doxygen options will be quoted automatically if they contain at least one space: CHM_FILE DIA_PATH DOCBOOK_OUTPUT DOCSET_FEEDNAME DOCSET_PUBLISHER_NAME DOT_FONTNAME DOT_PATH EXTERNAL_SEARCH_ID FILE_VERSION_FILTER GENERATE_TAGFILE HHC_LOCATION HTML_FOOTER HTML_HEADER HTML_OUTPUT HTML_STYLESHEET INPUT_FILTER LATEX_FOOTER LATEX_HEADER LATEX_OUTPUT LAYOUT_FILE MAN_OUTPUT MAN_SUBDIR MATHJAX_CODEFILE MSCGEN_PATH OUTPUT_DIRECTORY PERL_PATH PLANTUML_JAR_PATH PROJECT_BRIEF PROJECT_LOGO PROJECT_NAME QCH_FILE QHG_LOCATION QHP_CUST_FILTER_NAME QHP_VIRTUAL_FOLDER RTF_EXTENSIONS_FILE RTF_OUTPUT RTF_STYLESHEET_FILE SEARCHDATA_FILE USE_MDFILE_AS_MAINPAGE WARN_FORMAT WARN_LOGFILE XML_OUTPUT There are situations where it may be undesirable for a particular config option to be automatically quoted by doxygen_add_docs(), such as ALIASES which may need to include its own embedded quoting. The DOXYGEN_VERBATIM_VARS variable can be used to specify a list of Doxygen variables (in‐ cluding the leading DOXYGEN_ prefix) which should not be quoted. The project is then responsible for ensuring that those variables’ values make sense when placed directly in the Doxygen input file. In the case of list variables, list items are still separated by spaces, it is only the au‐ tomatic quoting that is skipped. For example, the following allows doxygen_add_docs() to apply quoting to DOXYGEN_PROJECT_BRIEF, but not each item in the DOXYGEN_ALIASES list (bracket syntax can also be used to make working with embedded quotes easier): set(DOXYGEN_PROJECT_BRIEF String with spaces) set(DOXYGEN_ALIASES [[somealias=@some_command param]] anotherAlias=@foobar ) set(DOXYGEN_VERBATIM_VARS DOXYGEN_ALIASES) The resultant Doxyfile will contain the following lines: PROJECT_BRIEF = String with spaces ALIASES = somealias=@some_command param anotherAlias=@foobar Deprecated Result Variables For compatibility with previous versions of CMake, the following variables are also defined but they are deprecated and should no longer be used: DOXYGEN_EXECUTABLE The path to the doxygen command. If projects need to refer to the doxygen executable directly, they should use the Doxygen::doxygen import target instead. DOXYGEN_DOT_FOUND True if the dot executable was found. DOXYGEN_DOT_EXECUTABLE The path to the dot command. If projects need to refer to the dot executable directly, they should use the Doxygen::dot import target in‐ stead. DOXYGEN_DOT_PATH The path to the directory containing the dot executable as reported in DOXYGEN_DOT_EXECUTABLE. The path may have forward slashes even on Windows and is not suitable for direct substitution into a Doxyfile.in template. If you need this value, get the IMPORTED_LOCATION prop‐ erty of the Doxygen::dot target and use get_filename_component() to extract the directory part of that path. You may also want to consider using file(TO_NATIVE_PATH) to prepare the path for a Doxygen configuration file. Deprecated Hint Variables DOXYGEN_SKIP_DOT This variable has no effect for the component form of find_package. In backward compatibility mode (i.e. without components list) it pre‐ vents the finder module from searching for Graphviz’s dot utility. FindEnvModules Locate an environment module implementation and make commands available to CMake scripts to use them. This is compatible with both Lua-based Lmod and TCL-based EnvironmentModules. This module is intended for the use case of setting up the compiler and library environment within a CTest Script (ctest -S). It can also be used in a CMake Script (cmake -P). NOTE: The loaded environment will not survive past the end of the calling process. Do not use this module in project code (CMakeLists.txt files) to load a compiler environment; it will not be available during the build. Instead load the environment manually before running CMake or using the generated build system. Example Usage set(CTEST_BUILD_NAME CrayLinux-CrayPE-Cray-dynamic) set(CTEST_BUILD_CONFIGURATION Release) set(CTEST_BUILD_FLAGS -k -j8) set(CTEST_CMAKE_GENERATOR Unix Makefiles) ... find_package(EnvModules REQUIRED) env_module(purge) env_module(load modules) env_module(load craype) env_module(load PrgEnv-cray) env_module(load craype-knl) env_module(load cray-mpich) env_module(load cray-libsci) set(ENV{CRAYPE_LINK_TYPE} dynamic) ... Result Variables This module will set the following variables in your project: EnvModules_FOUND True if a compatible environment modules framework was found. Cache Variables The following cache variable will be set: EnvModules_COMMAND The low level module command to use. Currently supported implementations are the Lua based Lmod and TCL based EnvironmentModules. Environment Variables ENV{MODULESHOME} Usually set by the module environment implementation, used as a hint to locate the module command to execute. Provided Functions This defines the following CMake functions for interacting with environment modules: env_module Execute an aribitrary module command: env_module(cmd arg1 ... argN) env_module( COMMAND cmd arg1 ... argN [OUTPUT_VARIABLE <out-var>] [RESULT_VARIABLE <ret-var>] ) The options are: cmd arg1 ... argN The module sub-command and arguments to execute as if they were passed directly to the module command in your shell environment. OUTPUT_VARIABLE <out-var> The standard output from executing the module command. RESULT_VARIABLE <ret-var> The return code from executing the module command. env_module_swap Swap one module for another: env_module_swap(out_mod in_mod [OUTPUT_VARIABLE <out-var>] [RESULT_VARIABLE <ret-var>] ) This is functionally equivalent to the module swap out_mod in_mod shell command. The options are: OUTPUT_VARIABLE <out-var> The standard output from executing the module command. RESULT_VARIABLE <ret-var> The return code from executing the module command. env_module_list Retrieve the list of currently loaded modules: env_module_list(<out-var>) This is functionally equivalent to the module list shell command. The result is stored in <out-var> as a properly formatted CMake semi‐ colon-separated list variable. env_module_avail Retrieve the list of available modules: env_module_avail([<mod-prefix>] <out-var>) This is functionally equivalent to the module avail <mod-prefix> shell command. The result is stored in <out-var> as a properly formatted CMake semicolon-separated list variable. FindEXPAT Find the native Expat headers and library. Expat is a stream-oriented XML parser library written in C. Imported Targets This module defines the following IMPORTED targets: EXPAT::EXPAT The Expat expat library, if found. Result Variables This module will set the following variables in your project: EXPAT_INCLUDE_DIRS where to find expat.h, etc. EXPAT_LIBRARIES the libraries to link against to use Expat. EXPAT_FOUND true if the Expat headers and libraries were found. FindFLEX Find Fast Lexical Analyzer (Flex) executable and provides a macro to generate custom build rules The module defines the following variables: FLEX_FOUND - True is flex executable is found FLEX_EXECUTABLE - the path to the flex executable FLEX_VERSION - the version of flex FLEX_LIBRARIES - The flex libraries FLEX_INCLUDE_DIRS - The path to the flex headers The minimum required version of flex can be specified using the standard syntax, e.g. find_package(FLEX 2.5.13) If flex is found on the system, the module provides the macro: FLEX_TARGET(Name FlexInput FlexOutput [COMPILE_FLAGS <string>] [DEFINES_FILE <string>] ) which creates a custom command to generate the FlexOutput file from the FlexInput file. If COMPILE_FLAGS option is specified, the next parameter is added to the flex command line. If flex is configured to output a header file, the DEFINES_FILE option may be used to specify its name. Name is an alias used to get details of this custom command. Indeed the macro defines the following variables: FLEX_${Name}_DEFINED - true is the macro ran successfully FLEX_${Name}_OUTPUTS - the source file generated by the custom rule, an alias for FlexOutput FLEX_${Name}_INPUT - the flex source file, an alias for ${FlexInput} FLEX_${Name}_OUTPUT_HEADER - the header flex output, if any. Flex scanners often use tokens defined by Bison: the code generated by Flex depends of the header generated by Bison. This module also defines a macro: ADD_FLEX_BISON_DEPENDENCY(FlexTarget BisonTarget) which adds the required dependency between a scanner and a parser where FlexTarget and BisonTarget are the first parameters of respectively FLEX_TARGET and BISON_TARGET macros. ==================================================================== Example: find_package(BISON) find_package(FLEX) BISON_TARGET(MyParser parser.y ${CMAKE_CURRENT_BINARY_DIR}/parser.cpp) FLEX_TARGET(MyScanner lexer.l ${CMAKE_CURRENT_BINARY_DIR}/lexer.cpp) ADD_FLEX_BISON_DEPENDENCY(MyScanner MyParser) include_directories(${CMAKE_CURRENT_BINARY_DIR}) add_executable(Foo Foo.cc ${BISON_MyParser_OUTPUTS} ${FLEX_MyScanner_OUTPUTS} ) target_link_libraries(Foo ${FLEX_LIBRARIES}) ==================================================================== FindFLTK2 Find the native FLTK 2.0 includes and library The following settings are defined FLTK2_FLUID_EXECUTABLE, where to find the Fluid tool FLTK2_WRAP_UI, This enables the FLTK2_WRAP_UI command FLTK2_INCLUDE_DIR, where to find include files FLTK2_LIBRARIES, list of fltk2 libraries FLTK2_FOUND,
