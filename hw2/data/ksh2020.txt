"Ksh" is a command and programming language that executes commands read from a terminal or a file. Rksh is a restricted version of the command interpreter ksh; See Invocation below for the meaning of arguments to the shell. Definitions. A metacharacter is one of the following characters: ; & ( ) ⎪ < > new-line space tab A blank is a tab or a space. An identifier is a sequence of letters, digits, or underscores starting with a letter or underscore. Identifiers are used as components of variable names. A vname is a sequence of one or more identifiers separated by a . and optionally preceded by a .. Vnames are used as function and variable names. A word is a sequence of characters from the character set defined by the current locale, exclud‐ ing non-quoted metacharacters. A command is a sequence of characters in the syntax of the shell language. The shell reads each command and carries out the desired action either directly or by invoking separate utilities. A built-in command is a command that is carried out by the shell itself without creating a separate process. Some commands are built-in purely for convenience and are not documented here. Built-ins that cause side effects in the shell environ‐ ment and built-ins that are found before performing a path search (see Execution below) are documented here. For historical reasons, some of these built-ins behave differently than other built-ins and are called special built-ins. Commands. A simple-command is a list of variable assignments (see Variable Assignments below) or a sequence of blank separated words which may be preceded by a list of variable assignments (see Environment below). The first word specifies the name of the command to be executed. Except as specified below, the remaining words are passed as arguments to the invoked command. The command name is passed as argument 0 (see exec(2)). The value of a simple-command is its exit status; 0-255 if it terminates normally; 256+signum if it terminates abnormally (the name of the signal corresponding to the exit status can be obtained via the -l option of the kill built-in utility). A pipeline is a sequence of one or more commands separated by ⎪. The standard output of each command but the last is connected by a pipe(2) to the standard input of the next command. Each command, except possibly the last, is run as a separate process; the shell waits for the last com‐ mand to terminate. The exit status of a pipeline is the exit status of the last command unless the pipefail option is enabled. Each pipeline can be preceded by the reserved word ! which causes the exit status of the pipeline to become 0 if the exit status of the last command is non-zero, and 1 if the exit status of the last command is 0. A list is a sequence of one or more pipelines separated by ;, &, ⎪&, &&, or ⎪⎪, and optionally terminated by ;, &, or ⎪&. Of these five symbols, ;, &, and ⎪& have equal precedence, which is lower than that of && and ⎪⎪. The symbols && and ⎪⎪ also have equal precedence. A semicolon (;) causes sequential execution of the preceding pipeline; an ampersand (&) causes asynchronous execution of the preceding pipeline (i.e., the shell does not wait for that pipeline to finish). The symbol ⎪& causes asynchronous execution of the preceding pipeline with a two-way pipe established to the parent shell; the standard input and output of the spawned pipeline can be written to and read from by the parent shell by applying the re‐ direction operators <& and >& with arg p to commands and by using -p option of the built-in commands read and print described later. The symbol && (⎪⎪) causes the list following it to be executed only if the preceding pipeline returns a zero (non-zero) value. One or more new-lines may ap‐ pear in a list instead of a semicolon, to delimit a command. The first item of the first pipeline of a list that is a simple command not begin‐ ning with a redirection, and not occurring within a while, until, or if list, can be preceded by a semicolon. This semicolon is ignored unless the showme option is enabled as described with the set built-in below. A command is either a simple-command or one of the following. Unless otherwise stated, the value returned by a command is that of the last sim‐ ple-command executed in the command. for vname [ in word ... ] ;do list ;done Each time a for command is executed, vname is set to the next word taken from the in word list. If in word ... is omitted, then the for command executes the do list once for each positional parameter that is set starting from 1 (see Parameter Expansion below). Execution ends when there are no more words in the list. for (( [expr1] ; [expr2] ; [expr3] )) ;do list ;done The arithmetic expression expr1 is evaluated first (see Arithmetic evaluation below). The arithmetic expression expr2 is repeatedly evalu‐ ated until it evaluates to zero and when non-zero, list is executed and the arithmetic expression expr3 evaluated. If any expression is omitted, then it behaves as if it evaluated to 1. select vname [ in word ... ] ;do list ;done A select command prints on standard error (file descriptor 2) the set of words, each preceded by a number. If in word ... is omitted, then the positional parameters starting from 1 are used instead (see Parameter Expansion below). The PS3 prompt is printed and a line is read from the standard input. If this line consists of the number of one of the listed words, then the value of the variable vname is set to the word corresponding to this number. If this line is empty, the selection list is printed again. Otherwise the value of the variable vname is set to null. The contents of the line read from standard input is saved in the variable REPLY. The list is executed for each se‐ lection until a break or end-of-file is encountered. If the REPLY variable is set to null by the execution of list, then the selection list is printed before displaying the PS3 prompt for the next selection. case word in [ [(]pattern [ ⎪ pattern ] ... ) list ;; ] ... esac A case command executes the list associated with the first pattern that matches word. The form of the patterns is the same as that used for file-name generation (see File Name Generation below). The ;; operator causes execution of case to terminate. If ;& is used in place of ;; the next subsequent list, if any, is executed. if list ;then list [ ;elif list ;then list ] ... [ ;else list ] ;fi The list following if is executed and, if it returns a zero exit status, the list following the first then is executed. Otherwise, the list following elif is executed and, if its value is zero, the list following the next then is executed. Failing each successive elif list, the else list is executed. If the if list has non-zero exit status and there is no else list, then the if command returns a zero exit status. while list ;do list ;done until list ;do list ;done A while command repeatedly executes the while list and, if the exit status of the last command in the list is zero, executes the do list; otherwise the loop terminates. If no commands in the do list are executed, then the while command returns a zero exit status; until may be used in place of while to negate the loop termination test. ((expression)) The expression is evaluated using the rules for arithmetic evaluation described below. If the value of the arithmetic expression is non-zero, the exit status is 0, otherwise the exit status is 1. (list) Execute list in a separate environment. Note, that if two adjacent open parentheses are needed for nesting, a space must be inserted to avoid evaluation as an arithmetic command as described above. { list;} list is simply executed. Note that unlike the metacharacters ( and ), { and } are reserved words and must occur at the beginning of a line or after a ; in order to be recognized. [[ expression ]] Evaluates expression and returns a zero exit status when expression is true. See Conditional Expressions below, for a description of ex‐ pression. function varname { list ;} varname () { list ;} Define a function which is referenced by varname. A function whose varname contains a . is called a discipline function and the portion of the varname preceding the last . must refer to an existing variable. The body of the function is the list of commands between { and }. A function defined with the function varname syntax can also be used as an argument to the . special built-in command to get the equiva‐ lent behavior as if the varname() syntax were used to define it. (See Functions below.) namespace varname { list ;} Defines or uses the name space identifier and runs the commands in list in this name space. (See Name Spaces below.) & [ name [ arg... ] ] Causes subsequent list commands terminated by & to be placed in the background job pool name. If name is omitted a default unnamed pool is used. Commands in a named background pool may be executed remotely. time [ pipeline ] If pipeline is omitted the user and system time for the current shell and completed child processes is printed on standard error. Other‐ wise, pipeline is executed and the elapsed time as well as the user and system time are printed on standard error. The TIMEFORMAT variable may be set to a format string that specifies how the timing information should be displayed. See Shell Variables below for a description of the TIMEFORMAT variable. The following reserved words are recognized as reserved only when they are the first word of a command and are not quoted: if then else elif fi case esac for while until do done { } function select time [[ ]] ! Variable Assignments. One or more variable assignments can start a simple command or can be arguments to the typeset, enum, export, or readonly special built-in com‐ mands as well as to other declaration commands created as types. The syntax for an assignment is of the form: varname=word varname[word]=word No space is permitted between varname and the = or between = and word. varname=(assign_list) No space is permitted between varname and the =. The variable varname is unset before the assignment. An assign_list can be one of the following: word ... Indexed array assignment. [word]=word ... Associative array assignment. If preceded by typeset -a this will create an indexed array instead. assignment ... Compound variable assignment. This creates a compound variable varname with sub-variables of the form varname.name, where name is the name portion of assignment. The value of varname will contain all the assignment elements. Additional assign‐ ments made to sub-variables of varname will also be displayed as part of the value of varname. If no assignments are speci‐ fied, varname will be a compound variable allowing subsequence child elements to be defined. typeset [options] assignment ... Nested variable assignment. Multiple assignments can be specified by separating each of them with a ;. The previous value is unset before the assignment. Other declaration commands such as readonly, enum, and other declaration commands can be used in place of typeset. . filename Include the assignment commands contained in filename. In addition, a += can be used in place of the = to signify adding to or appending to the previous value. When += is applied to an arithmetic type, word is evaluated as an arithmetic expression and added to the current value. When applied to a string variable, the value defined by word is appended to the value. For compound assignments, the previous value is not unset and the new values are appended to the current ones provided that the types are compatible. The right hand side of a variable assignment undergoes all the expansion listed below except word splitting, brace expansion, and file name gener‐ ation. When the left hand side is an assignment is a compound variable and the right hand is the name of a compound variable, the compound vari‐ able on the right will be copied or appended to the compound variable on the left. Comments. A word beginning with # causes that word and all the following characters up to a new-line to be ignored. Aliasing. The first word of each command is replaced by the text of an alias if an alias for this word has been defined. An alias name consists of any num‐ ber of characters excluding metacharacters, quoting characters, file expansion characters, parameter expansion and command substitution charac‐ ters, the characters / and =. The replacement string can contain any valid shell script including the metacharacters listed above. The first word of each command in the replaced text, other than any that are in the process of being replaced, will be tested for aliases. If the last character of the alias value is a blank then the word following the alias will also be checked for alias substitution. Aliases can be used to re‐ define built-in commands but cannot be used to redefine the reserved words listed above. Aliases can be created and listed with the alias command and can be removed with the unalias command. Aliasing is performed when scripts are read, not while they are executed. Therefore, for an alias to take effect, the alias definition command has to be executed before the command which references the alias is read. The following aliases are compiled into the shell but can be unset or redefined: autoload=′typeset -fu′ bool=′_Bool′ command=′command ′ compound=′typeset -C′ fc=hist float=′typeset -lE′ functions=′typeset -f′ hash=′alias -t --′ history=′hist -l′ integer=′typeset -li′ nameref=′typeset -n′ nohup=′nohup ′ r=′hist -s′ redirect=′command exec′ source=′command .′ stop=′kill -s STOP′ suspend=′kill -s STOP $$′ type=′whence -v′ Tilde Substitution. After alias substitution is performed, each word is checked to see if it begins with an unquoted ∼. For tilde substitution, word also refers to the word portion of parameter expansion (see Parameter Expansion below). If it does, then the word up to a / is checked to see if it matches a user name in the password database (See getpwname(3).) If a match is found, the ∼ and the matched login name are replaced by the login directory of the matched user. If no match is found, the original text is left unchanged. A ∼ by itself, or in front of a /, is replaced by $HOME. A ∼ followed by a + or - is replaced by the value of $PWD and $OLDPWD respectively. A ∼ followed by {fd} where fd is a file descriptor number or the name of a variable whose value is a file descriptor, is replaced by a string that is the equivalent to the path name of the file or directory cor‐ responding to this file descriptor. In addition, when expanding a variable assignment, tilde substitution is attempted when the value of the assignment begins with a ∼, and when a ∼ appears after a :. The : also terminates a ∼ login name. Command Substitution. The standard output from a command list enclosed in parentheses preceded by a dollar sign ( $(list) ), or in a brace group preceded by a dollar sign ( ${ list;} ), or in a pair of grave accents (``) may be used as part or all of a word; trailing new-lines are removed. In the second case, the { and } are treated as a reserved words so that { must be followed by a blank and } must appear at the beginning of the line or follow a ;. In the third (obsolete) form, the string between the quotes is processed for special quoting characters before the command is executed (see Quot‐ ing below). The command substitution $(cat file) can be replaced by the equivalent but faster $(<file). The command substitution $(n<#) will ex‐ pand to the current byte offset for file descriptor n. Except for the second form, the command list is run in a subshell so that no side effects are possible. For the second form, the final } will be recognized as a reserved word after any token. Arithmetic Substitution. An arithmetic expression enclosed in double parentheses preceded by a dollar sign ( $(()) ) is replaced by the value of the arithmetic expression within the double parentheses. Process Substitution. Each command argument of the form <(list) or >(list) will run process list asynchronously connected to some file in /dev/fd if this directory ex‐ ists, or else a fifo a temporary directory. The name of this file will become the argument to the command. If the form with > is selected then writing on this file will provide input for list. If < is used, then the file passed as an argument will contain the output of the list process. For example, paste <(cut -f1 file1) <(cut -f3 file2) | tee >(process1) >(process2) cuts fields 1 and 3 from the files file1 and file2 respectively, pastes the results together, and sends it to the processes process1 and process2, as well as putting it onto the standard output. Note that the file, which is passed as an argument to the command, is a UNIX pipe(2) so programs that expect to lseek(2) on the file will not work. Process substitution of the form <(list) can also be used with the < redirection operator which causes the output of list to be standard input or the input for whatever file descriptor is specified. Parameter Expansion. A parameter is a variable, one or more digits, or any of the characters *, @, #, ?, -, $, and !. A variable is denoted by a vname. To create a variable whose vname contains a ., a variable whose vname consists of everything before the last . must already exist. A variable has a value and zero or more attributes. Variables can be assigned values and attributes by using the typeset special built-in command. The attributes supported by the shell are described later with the typeset special built-in command. Exported variables pass values and attributes to the environment. The shell supports both indexed and associative arrays. An element of an array variable is referenced by a subscript. A subscript for an indexed array is denoted by an arithmetic expression (see Arithmetic evaluation below) between a [ and a ]. To assign values to an indexed array, use vname=(value ...) or set -A vname value ... . The value of all non-negative subscripts must be in the range of 0 through 4,194,303. A negative subscript is treated as an offset from the maximum current index +1 so that -1 refers to the last element. Indexed arrays can be declared with the -a option to typeset. Indexed arrays need not be declared. Any reference to a variable with a valid subscript is legal and an array will be created if necessary. An associative array is created with the -A option to typeset. A subscript for an associative array is denoted by a string enclosed between [ and ]. Referencing any array without a subscript is equivalent to referencing the array with subscript 0. The value of a variable may be assigned by writing: vname=value [ vname=value ] ... or vname[subscript]=value [ vname[subscript]=value ] ... Note that no space is allowed before or after the =. Attributes assigned by the typeset special built-in command apply to all elements of the array. An array element can be a simple variable, a com‐ pound variable or an array variable. An element of an indexed array can be either an indexed array or an associative array. An element of an as‐ sociative array can also be either. To refer to an array element that is part of an array element, concatenate the subscript in brackets. For example, to refer to the foobar element of an associative array that is defined as the third element of the indexed array, use ${vname[3][foobar]} A nameref is a variable that is a reference to another variable. A nameref is created with the -n attribute of typeset. The value of the vari‐ able at the time of the typeset command becomes the variable that will be referenced whenever the nameref variable is used. The name of a nameref cannot contain a .. When a variable or function name contains a ., and the portion of the name up to the first . matches the name of a nameref, the variable referred to is obtained by replacing the nameref portion with the name of the variable referenced by the nameref. If a nameref is used as the index of a for loop, a name reference is established for each item in the list. A nameref provides a convenient way to refer to the variable inside a function whose name is passed as an argument to a function. For example, if the name of a variable is passed as the first argu‐ ment to a function, the command typeset -n var=$1 inside the function causes references and assignments to var to be references and assignments to the variable whose name has been passed to the function. If any of the floating point attributes, -E, -F, or -X, or the integer attribute, -i, is set for vname, then the value is subject to arithmetic evaluation as described below. Positional parameters, parameters denoted by a number, may be assigned values with the set special built-in command. Parameter $0 is set from ar‐ gument zero when the shell is invoked. The character $ is used to introduce substitutable parameters. ${parameter} The shell reads all the characters from ${ to the matching } as part of the same word even if it contains braces or metacharacters. The value, if any, of the parameter is substituted. The braces are required when parameter is followed by a letter, digit, or underscore that is not to be interpreted as part of its name, when the variable name contains a .. The braces are also required when a variable is sub‐ scripted unless it is part of an Arithmetic Expression or a Conditional Expression. If parameter is one or more digits then it is a posi‐ tional parameter. A positional parameter of more than one digit must be enclosed in braces. If parameter is * or @, then all the posi‐ tional parameters, starting with $1, are substituted (separated by a field separator character). If an array vname with last subscript * @, or for index arrays of the form sub1 .. sub2. is used, then the value for each of the elements between sub1 and sub2 inclusive (or all elements for * and @) is substituted, separated by the first character of the value of IFS. ${#parameter} If parameter is * or @, the number of positional parameters is substituted. Otherwise, the length of the value of the parameter is substi‐ tuted. ${#vname[*]} ${#vname[@]} The number of elements in the array vname is substituted. ${@vname} Expands to the type name (See Type Variables below) or attributes of the variable referred to by vname. ${$parameter} If $parameter expands to the name of a variable, this expands to the value of that variable. Otherwise, it expands to the empty string. It is undefined for special parameters. ${!vname} Expands to the name of the variable referred to by vname. This will be vname except when vname is a name reference. ${!vname[subscript]} Expands to name of the subscript unless subscript is *, @. or of the form sub1 .. sub2. When subscript is *, the list of array sub‐ scripts for vname is generated. For a variable that is not an array, the value is 0 if the variable is set. Otherwise it is null. When subscript is @, same as above, except that when used in double quotes, each array subscript yields a separate argument. When subscript is of the form sub1 .. sub2 it expands to the list of subscripts between sub1 and sub2 inclusive using the same quoting rules as @. ${!prefix*} Expands to the names of the variables whose names begin with prefix. ${parameter:-word} If parameter is set and is non-null then substitute its value; otherwise substitute word. ${parameter:=word} If parameter is not set or is null then set it to word; the value of the parameter is then substituted. Positional parameters may not be assigned to in this way. ${parameter:?word} If parameter is set and is non-null then substitute its value; otherwise, print word and exit from the shell (if not interactive). If word is omitted then a standard message is printed. ${parameter:+word} If parameter is set and is non-null then substitute word; otherwise substitute nothing. In the above, word is not evaluated unless it is to be used as the substituted string, so that, in the following example, pwd is executed only if d is not set or is null: print ${d:-$(pwd)} If the colon ( : ) is omitted from the above expressions, then the shell only checks whether parameter is set or not. ${parameter:offset:length} ${parameter:offset} Expands to the portion of the value of parameter starting at the character (counting from 0) determined by expanding offset as an arith‐ metic expression and consisting of the number of characters determined by the arithmetic expression defined by length. In the second form, the remainder of the value is used. If A negative offset counts backwards from the end of parameter. Note that one or more blanks is re‐ quired in front of a minus sign to prevent the shell from interpreting the operator as :-. If parameter is * or @, or is an array name in‐ dexed by * or @, then offset and length refer to the array index and number of elements respectively. A negative offset is taken relative to one greater than the highest subscript for indexed arrays. The order for associate arrays is unspecified. ${parameter#pattern} ${parameter##pattern} If the shell pattern matches the beginning of the value of parameter, then the value of this expansion is the value of the parameter with the matched portion deleted; otherwise the value of this parameter is substituted. In the first form the smallest matching pattern is deleted and in the second form the largest matching pattern is deleted. When parameter is @, *, or an array variable with subscript @ or *, the substring operation is applied to each element in turn. ${parameter%pattern} ${parameter%%pattern} If the shell pattern matches the end of the value of parameter, then the value of this expansion is the value of the parameter with the matched part deleted; otherwise substitute the value of parameter. In the first form the smallest matching pattern is deleted and in the second form the largest matching pattern is deleted. When parameter is @, *, or an array variable with subscript @ or *, the substring op‐ eration is applied to each element in turn. ${parameter/pattern/string} ${parameter//pattern/string} ${parameter/#pattern/string} ${parameter/%pattern/string} Expands parameter and replaces the longest match of pattern with the given string. Each occurrence of n in string is replaced by the por‐ tion of parameter that matches the n-th sub-pattern. In the first form, only the first occurrence of pattern is replaced. In the second form, each match for pattern is replaced by the given string. The third form restricts the pattern match to the beginning of the string while the fourth form restricts the pattern match to the end of the string. When string is null, the pattern will be deleted and the / in front of string may be omitted. When parameter is @, *, or an array variable with subscript @ or *, the substitution operation is applied to each element in turn. In this case, the string portion of word will be re-evaluated for each element. ${parameter^pattern} ${parameter^^pattern} ${parameter,pattern} ${parameter,,pattern} Case modification. This expansion modifies the case of alphabetic characters in parameter. The pattern is expanded to produce a pat‐ tern just as in pathname expansion. The ^ operator converts lowercase characters matching pattern to uppercase. The , operator converts matching uppercase characters to lowercase. The ^^ and ,, expansions convert all matched character in the expanded value. The ^ and , expansions match and convert only the first character in the expanded value. If pattern is omitted it is treated like a ?, which matches every character. If parameter is @ or *, or an array subscripted by @ or *, the case modification operation is applied to each element. The following parameters are automatically set by the shell: # The number of positional parameters in decimal. - Options supplied to the shell on invocation or by the set command. ? The decimal value returned by the last executed command. $ The process number of this shell. _ Initially, the value of _ is an absolute pathname of the shell or script being executed as passed in the environment. Subsequently it is assigned the last argument of the previous command. This parameter is not set for commands which are asynchronous. This pa‐ rameter is also used to hold the name of the matching MAIL file when checking for mail. While defining a compound variable or a type, _ is initialized as a reference to the compound variable or type. When a discipline function is invoked, _ is initialized as a reference to the variable associated with the call to this function. Finally when _ is used as the name of the first variable of a type definition, the new type is derived from the type of the first variable (See Type Variables below.). ! The process id or the pool name and job number of the last background command invoked or the most recent job put in the background with the bg built-in command. Background jobs started in a named pool will be in the form pool.number where pool is the pool name and number is the job number within that pool. .sh.command When processing a DEBUG trap, this variable contains the current command line that is about to run. .sh.edchar This variable contains the value of the keyboard character (or sequence of characters if the first character is an ESC, ascii 033) that has been entered when processing a KEYBD trap (see Key Bindings below). If the value is changed as part of the trap action, then the new value replaces the key (or key sequence) that caused the trap. .sh.edcol The character position of the cursor at the time of the most recent KEYBD trap. .sh.edmode The value is set to ESC when processing a KEYBD trap while in vi insert mode. (See Vi Editing Mode below.) Otherwise, .sh.edmode is null when processing a KEYBD trap. .sh.edtext The characters in the input buffer at the time of the most recent KEYBD trap. The value is null when not processing a KEYBD trap. .sh.file The pathname of the file than contains the current command. .sh.fun The name of the current function that is being executed. .sh.level Set to the current function depth. This can be changed inside a DEBUG trap and will set the context to the specified level. .sh.lineno Set during a DEBUG trap to the line number for the caller of each function. .sh.match An indexed array which stores the most recent match and sub-pattern matches after conditional pattern matches that match and after variables expansions using the operators #, %, or /. The 0-th element stores the complete match and the i-th. element stores the i-th submatch. For // the array is two dimensional with the first subscript indicating the most recent match and sub-pattern match and the second script indicating which match with 0 representing the first match. The .sh.match variable becomes unset when the variable that has expanded is assigned a new value. .sh.math Used for defining arithmetic functions (see Arithmetic evaluation below). and stores the list of user defined arithmetic functions. .sh.name Set to the name of the variable at the time that a discipline function is invoked. .sh.op_astbin The directory where several shell built-in commands are bound to. The default is /opt/ast/bin. When the value is /bin, then builtins will be bound to /bin or /usr/bin depending on where the executable is found. This variable can be set by including it in
